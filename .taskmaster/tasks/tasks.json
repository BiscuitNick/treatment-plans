{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Project Foundation and AWS Configuration",
        "description": "Set up the Next.js 16 application with Tailwind CSS v4, shadcn/ui, and configure AWS SDK clients for S3 and Cognito integration.",
        "details": "1. Initialize Next.js 16 App Router project with TypeScript.\n2. Install and configure Tailwind CSS v4 and shadcn/ui.\n3. Create `src/lib/aws-config.ts` to export configured AWS clients (S3, Cognito).\n4. Implement environment variable validation for AWS credentials (AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, COGNITO_USER_POOL_ID, S3_BUCKET_NAME).\n5. Ensure Turbopack is active in dev script.",
        "testStrategy": "Verify the build passes `npm run build`. Verify AWS clients can be instantiated without errors locally using mock env vars.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Upgrade Project to Next.js 16 and Enable Turbopack",
            "description": "Update the existing Next.js 15 application to Next.js 16 and configure the development script to use Turbopack.",
            "dependencies": [],
            "details": "Update `package.json` dependencies for `next`, `react`, and `react-dom` to the versions required for Next.js 16. Update the `dev` script in `package.json` to include the `--turbo` flag. Verify `tsconfig.json` settings align with Next.js 16 requirements.",
            "status": "done",
            "testStrategy": "Run `npm run dev` and verify the server starts with Turbopack active. Check `npm run build` for successful compilation."
          },
          {
            "id": 2,
            "title": "Configure Tailwind CSS v4 and shadcn/ui",
            "description": "Install and configure Tailwind CSS v4 and initialize shadcn/ui components structure.",
            "dependencies": [
              1
            ],
            "details": "Install Tailwind CSS v4 packages. Update the CSS entry point to use the new v4 directives. Run `npx shadcn-ui@latest init` to generate `components.json` and set up the `src/components` directory structure. Verify global styles are applied.",
            "status": "done",
            "testStrategy": "Import a sample shadcn button component on the home page and verify it renders with correct styling."
          },
          {
            "id": 3,
            "title": "Implement Environment Variable Validation",
            "description": "Create a validation schema for required AWS environment variables using Zod to ensure runtime safety.",
            "dependencies": [
              1
            ],
            "details": "Install `zod`. Create `src/env.ts` (or `src/lib/env.ts`). Define a schema requiring `AWS_REGION`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `COGNITO_USER_POOL_ID`, and `S3_BUCKET_NAME`. Export a sanitized `env` object that throws an error if variables are missing.",
            "status": "done",
            "testStrategy": "Create a unit test that attempts to import the env module with missing variables and asserts that it throws a validation error."
          },
          {
            "id": 4,
            "title": "Install AWS SDK Client Dependencies",
            "description": "Install the modular AWS SDK packages required for S3 and Cognito integration.",
            "dependencies": [
              1
            ],
            "details": "Run `npm install @aws-sdk/client-s3 @aws-sdk/client-cognito-identity-provider`. Ensure these are added to `package.json` dependencies and that no conflicting versions exist.",
            "status": "done",
            "testStrategy": "Inspect `package.json` to verify dependencies are listed. Run `npm install` to ensure a clean lockfile."
          },
          {
            "id": 5,
            "title": "Create AWS Client Configuration Module",
            "description": "Implement the centralized AWS configuration file exporting initialized S3 and Cognito clients.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create `src/lib/aws-config.ts`. Import the validated `env` object and AWS SDK classes. Instantiate `S3Client` and `CognitoIdentityProviderClient` using the validated credentials and region. Export these instances for use in API routes.",
            "status": "done",
            "testStrategy": "Create a test script that imports the clients from `src/lib/aws-config.ts` and verifies they are instances of the expected SDK classes."
          }
        ]
      },
      {
        "id": 2,
        "title": "Database Schema and Prisma Setup",
        "description": "Configure Prisma with PostgreSQL and define the schema including User, Session, TreatmentPlan, and PlanVersion models as specified in the PRD.",
        "details": "1. Initialize Prisma: `npx prisma init`.\n2. Copy the provided schema into `prisma/schema.prisma`, ensuring all models (User, Session, TreatmentPlan, PlanVersion) and enums (UserRole) are exactly as specified.\n3. Configure the datasource to point to the RDS PostgreSQL instance (via env var DATABASE_URL).\n4. Run `npx prisma migrate dev --name init` to create the initial migration and generate the Prisma Client.\n5. Create a seed script to populate static personas ('Anxious Andy', etc.) if needed for testing.",
        "testStrategy": "Run prisma generate and verify the client is generated. Execute a script to insert a dummy User and Session to verify DB connection.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Prisma and Configure Environment",
            "description": "Initialize the Prisma project structure and configure the database connection environment variables.",
            "dependencies": [],
            "details": "Execute `npx prisma init` to create the prisma folder. Update the `.env` file to set the `DATABASE_URL` variable to point to the RDS PostgreSQL instance. Ensure the .gitignore includes the local env file.",
            "status": "done",
            "testStrategy": "Verify that `prisma/schema.prisma` exists and that the `DATABASE_URL` is correctly read from the environment variables."
          },
          {
            "id": 2,
            "title": "Define User and Session Schema Models",
            "description": "Draft the core User and Session data models within the Prisma schema file.",
            "dependencies": [
              1
            ],
            "details": "In `prisma/schema.prisma`, define the `User` model including fields for id, email, name, and role. Define the `Session` model with fields for id, userId, transcript, and audioUrl. Establish the one-to-many relation between User and Session.",
            "status": "done",
            "testStrategy": "Run `npx prisma validate` to ensure the schema syntax is correct and relations are valid."
          },
          {
            "id": 3,
            "title": "Define Treatment Plan and Versioning Schema",
            "description": "Complete the schema definition by adding TreatmentPlan, PlanVersion models, and Enums.",
            "dependencies": [
              2
            ],
            "details": "Add `TreatmentPlan` (linked to Session) and `PlanVersion` (linked to TreatmentPlan) models. Define the `UserRole` enum. Ensure `PlanVersion` captures snapshot data to support the version control requirement specified in Task 10.",
            "status": "done",
            "testStrategy": "Run `npx prisma validate` again to confirm the full schema graph including deep relations is valid."
          },
          {
            "id": 4,
            "title": "Execute Initial Migration and Generate Client",
            "description": "Apply the schema changes to the database and generate the Prisma Client library.",
            "dependencies": [
              3
            ],
            "details": "Run `npx prisma migrate dev --name init` to create the tables in the PostgreSQL database. This will also automatically trigger `prisma generate` to build the type-safe client in `node_modules`.",
            "status": "done",
            "testStrategy": "Inspect the connected PostgreSQL database to verify table creation. Check `node_modules/@prisma/client` to ensure generation was successful."
          },
          {
            "id": 5,
            "title": "Create and Execute Database Seed Script",
            "description": "Develop and run a seed script to populate the database with initial testing personas.",
            "dependencies": [
              4
            ],
            "details": "Create `prisma/seed.ts`. Add logic to upsert a test User (e.g., 'Anxious Andy' context) and a dummy Session. Add the seed command to `package.json` and run `npx prisma db seed` to populate the database.",
            "status": "done",
            "testStrategy": "Use `npx prisma studio` or a direct SQL query to verify that the seed user and session records exist in the database."
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement File Upload and Pre-signed URL API",
        "description": "Create the S3 upload flow allowing users to get a pre-signed URL for secure audio/video uploading.",
        "details": "1. Create API route `src/app/api/upload-url/route.ts`.\n2. Implement POST handler to accept filename/contentType.\n3. Use `@aws-sdk/s3-request-presigner` and `@aws-sdk/client-s3` to generate a signed URL for `PutObject`.\n4. Enforce file constraints (max 25MB) if possible here or strictly in frontend validation.\n5. Return the upload URL and the final public URL to the client.",
        "testStrategy": "Use Postman/curl to hit the endpoint, get a URL, and verify a file can be uploaded to the S3 bucket using that URL.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize AWS S3 Client Configuration",
            "description": "Set up the AWS S3 client instance with necessary environment variables and configuration.",
            "dependencies": [],
            "details": "Import `S3Client` from `@aws-sdk/client-s3`. Configure it using `process.env.AWS_REGION`, `AWS_ACCESS_KEY_ID`, and `AWS_SECRET_ACCESS_KEY`. Create a shared utility or instantiate within the route handle if preferred.",
            "status": "done",
            "testStrategy": "Verify that the client initializes without throwing credential errors by logging the config (excluding secrets) during a dry run."
          },
          {
            "id": 2,
            "title": "Create API Route and Request Validation",
            "description": "Scaffold the Next.js API route and implement validation for the incoming request body.",
            "dependencies": [],
            "details": "Create file `src/app/api/upload-url/route.ts`. Define a `POST` handler. Parse the request body to extract `filename` and `contentType`. Validate that these fields exist and `contentType` matches allowed audio/video types.",
            "status": "done",
            "testStrategy": "Send POST requests with valid and invalid payloads via Postman. Confirm 400 Bad Request is returned for missing fields."
          },
          {
            "id": 3,
            "title": "Implement Unique Object Key Generation",
            "description": "Develop logic to generate unique S3 object keys to prevent file overwrites.",
            "dependencies": [
              2
            ],
            "details": "Generate a unique file path for the S3 bucket, such as `uploads/${crypto.randomUUID()}-${filename}`. Sanitize the original filename to remove special characters that might cause issues in URLs.",
            "status": "done",
            "testStrategy": "Unit test the key generation logic to ensure it produces unique strings and properly sanitizes input filenames."
          },
          {
            "id": 4,
            "title": "Generate S3 Presigned PUT URL",
            "description": "Use the AWS SDK presigner to generate a secure, time-limited URL for the file upload.",
            "dependencies": [
              1,
              3
            ],
            "details": "Import `PutObjectCommand` and `getSignedUrl` from `@aws-sdk/s3-request-presigner`. Instantiate the command with Bucket, Key, and ContentType. specific `expiresIn` (e.g., 300 seconds).",
            "status": "done",
            "testStrategy": "Log the generated URL and attempt a manual PUT request with the specific Content-Type header to verify AWS accepts it."
          },
          {
            "id": 5,
            "title": "Finalize API Response and Error Handling",
            "description": "Construct the final JSON response and implement global error handling for the route.",
            "dependencies": [
              4
            ],
            "details": "Return a JSON object containing `uploadUrl` (signed URL) and `publicUrl` (e.g., `https://{bucket}.s3.{region}.amazonaws.com/{key}`). Wrap logic in try/catch blocks to handle AWS SDK errors and return 500 status codes appropriately.",
            "status": "done",
            "testStrategy": "End-to-end test: Call the API, receive the URLs, and verify the publicUrl structure matches the S3 bucket pattern."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Transcription Service (Whisper) API",
        "description": "Build the transcription API route using OpenAI Whisper via Vercel AI SDK or direct OpenAI API, handling long-running processes.",
        "details": "1. Create `src/app/api/transcribe/route.ts`.\n2. Set `export const maxDuration = 300;` to allow for 5-minute timeouts.\n3. Accept an audio URL (S3 public URL).\n4. Fetch the file from the URL and pass it to OpenAI Whisper (v2/v3).\n5. Handle potential errors and format the transcript text for response.\n6. Ensure API security (validate authenticated session).",
        "testStrategy": "Upload a short test audio file to S3, send its URL to the endpoint, and verify the returned text matches the audio content.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Transcription API Route",
            "description": "Create the API route file and configure the serverless function settings for long execution times required by audio processing.",
            "dependencies": [],
            "details": "Create `src/app/api/transcribe/route.ts`. Set `export const maxDuration = 300;` (5 minutes) to prevent timeouts on Vercel during long transcriptions. Initialize the OpenAI client instance using the project's environment variables.",
            "status": "done",
            "testStrategy": "Check that the endpoint exists and returns a simple 200 OK on a GET request to verify routing."
          },
          {
            "id": 2,
            "title": "Implement Authentication and Input Validation",
            "description": "Secure the endpoint by validating the user session and ensuring the input payload is a valid S3 URL.",
            "dependencies": [
              1
            ],
            "details": "Import the auth helper to check for a valid session; return 401 if unauthorized. Parse the request body (e.g., using Zod) to ensure `audioUrl` is provided and matches the expected S3 bucket domain pattern to prevent processing malicious URLs.",
            "status": "done",
            "testStrategy": "Send requests with no session and invalid URLs to confirm 401 and 400 error responses respectively."
          },
          {
            "id": 3,
            "title": "Implement Audio Fetching from S3",
            "description": "Retrieve the audio file from the provided public S3 URL and prepare it for the OpenAI API ingestion.",
            "dependencies": [
              2
            ],
            "details": "Use `fetch(audioUrl)` to retrieve the file stream. Convert the response body into a `File` object or `Buffer` compatible with the OpenAI Node SDK `toFile` utility or direct stream handling. Ensure proper content-type detection.",
            "status": "done",
            "testStrategy": "Log the file size and type after fetching to verify the download mechanism works for a known public S3 file."
          },
          {
            "id": 4,
            "title": "Integrate OpenAI Whisper API",
            "description": "Send the retrieved audio data to OpenAI's Whisper model to generate the text transcription.",
            "dependencies": [
              3
            ],
            "details": "Call `openai.audio.transcriptions.create` specifying `model: 'whisper-1'`. Pass the file buffer prepared in the previous step. Ensure `response_format` is set to 'json' or 'text' depending on the parsing needs.",
            "status": "done",
            "testStrategy": "Mock the OpenAI API response to verify the integration code handles the promise resolution correctly."
          },
          {
            "id": 5,
            "title": "Finalize Error Handling and Response Structure",
            "description": "Structure the API response and handle potential failures like timeouts, upstream API errors, or file size limits.",
            "dependencies": [
              4
            ],
            "details": "Wrap the main logic in a try-catch block. Handle specific OpenAI errors (e.g., 413 Payload Too Large) gracefully. Return a standardized JSON response `{ text: string }` on success or `{ error: string }` on failure.",
            "status": "done",
            "testStrategy": "Upload a valid short audio file and verify the full flow returns a JSON object containing the transcript text."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Safety Guardrails Service",
        "description": "Develop the safety scanning logic to detect high-risk content before plan generation.",
        "details": "1. Create `src/services/safety.ts`.\n2. Implement a regex-based keyword scanner for immediate flags (self-harm, violence keywords).\n3. Implement a secondary check using `gpt-4o-mini` to classify the transcript risk level (LOW/MEDIUM/HIGH).\n4. Define the return interface to include a boolean `safeToGenerate` and a `riskFlags` array.",
        "testStrategy": "Unit test with sample texts containing trigger words to ensure regex catches them. Test with a clean text to ensure it passes.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Safety Service Types and Interfaces",
            "description": "Create the service file and define the TypeScript interfaces and enums required for the safety scanning logic.",
            "dependencies": [],
            "details": "Initialize `src/services/safety.ts`. Define the `SafetyCheckResult` interface containing `safeToGenerate` (boolean), `riskLevel` (enum: LOW, MEDIUM, HIGH), and `riskFlags` (string array). Export these types for use in the API layer.",
            "status": "done",
            "testStrategy": null
          },
          {
            "id": 2,
            "title": "Implement Regex-based Keyword Scanner",
            "description": "Develop a synchronous function to detect immediate high-risk keywords using regular expressions.",
            "dependencies": [
              1
            ],
            "details": "In `src/services/safety.ts`, implement a helper function that checks the input transcript against a list of regex patterns covering self-harm, violence, and abuse. This should return a preliminary list of flags if matches are found.",
            "status": "done",
            "testStrategy": "Unit test with strings containing known trigger words to verify detection, and clean strings to ensure no false positives."
          },
          {
            "id": 3,
            "title": "Implement LLM-based Semantic Risk Analysis",
            "description": "Create a function using `gpt-4o-mini` to analyze the transcript for contextual risks that regex might miss.",
            "dependencies": [
              1
            ],
            "details": "Implement an async function that calls `gpt-4o-mini` via Vercel AI SDK. The prompt must instruct the model to classify the transcript's risk level (LOW/MEDIUM/HIGH) and explain why. Ensure the output is structured (e.g., using `generateObject` or strict JSON mode).",
            "status": "done",
            "testStrategy": "Mock the OpenAI API response with various risk scenarios to verify the parser correctly maps the LLM output to the internal risk types."
          },
          {
            "id": 4,
            "title": "Orchestrate Main Safety Evaluation Function",
            "description": "Combine the regex and LLM checks into a single exported service function.",
            "dependencies": [
              2,
              3
            ],
            "details": "Export a function `validateContent(transcript: string)`. Logic: 1. Run regex check. 2. If regex finds critical flags, mark as unsafe immediately. 3. If regex is clear or ambiguous, await the LLM check. 4. Aggregate results into the final `SafetyCheckResult` object.",
            "status": "done",
            "testStrategy": "Integration test calling the main function. Verify that a regex hit returns immediately without calling the LLM (optimization), while clean text triggers the LLM check."
          },
          {
            "id": 5,
            "title": "Create Unit Tests for Safety Guardrails",
            "description": "Write comprehensive unit tests to ensure the guardrails service performs reliably under various conditions.",
            "dependencies": [
              4
            ],
            "details": "Create `src/services/safety.test.ts`. Include test cases for: 1. Explicit violent keywords (regex catch). 2. Subtle context implying harm (LLM catch). 3. Completely benign text. 4. Error handling if the LLM service fails.",
            "status": "done",
            "testStrategy": "Run `npm test` and ensure 100% coverage for the safety service logic."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Plan Generation API (GPT-4o)",
        "description": "Create the core AI generation logic that produces the structured treatment plan using Zod schemas.",
        "details": "1. Create `src/app/api/analyze/route.ts` with `maxDuration = 300`.\n2. Integrate Vercel AI SDK `generateObject` function using the `gpt-4o` model.\n3. Define the Zod schema strictly as provided in the PRD (clinicalGoals, clientGoals, riskScore, etc.).\n4. Construct the prompt to include: Transcript, Previous Plan (if exists), and Therapist Preferences.\n5. Integrate the Safety Service (Task 5) at the start of the flow. If high risk, flag it.\n6. Save the result to the database via Prisma.",
        "testStrategy": "Mock the OpenAI call to return valid JSON. Verify the API parses it correctly, validates against Zod, and saves to the DB.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Zod Schemas for Treatment Plan Structure",
            "description": "Create the detailed Zod schema definitions to strictly type the AI output for the treatment plan, covering clinical goals, client goals, and risk scores.",
            "dependencies": [],
            "details": "Create a shared utility file (e.g., `src/lib/schemas/plan.ts`). Define Zod objects for `ClinicalGoal`, `ClientGoal`, `RiskAssessment`, and the master `TreatmentPlanSchema`. Ensure strict typing to handle optional fields like 'previous_plan_reference'. These schemas will be passed to the Vercel AI SDK `generateObject` function to enforce structured JSON output.",
            "status": "done",
            "testStrategy": "Create unit tests that validate a mock JSON object representing a full treatment plan against the Zod schema to ensure validation rules (min/max length, required fields) work as expected."
          },
          {
            "id": 2,
            "title": "Implement Prompt Engineering and Context Assembly Service",
            "description": "Build the service logic to assemble the prompt context, including the current session transcript, patient history, and therapist preferences.",
            "dependencies": [
              1
            ],
            "details": "Develop a helper function `assemblePromptContext` that fetches the previous plan (if available) and therapist settings from the DB. Combine these with the current session transcript into a coherent system and user prompt structure. Optimize the prompt text to instruct the model on how to interpret clinical nuances and map them to the specific Zod fields defined in subtask 1.",
            "status": "done",
            "testStrategy": "Unit test the `assemblePromptContext` function with mock inputs (transcript text, mock history object) and verify the returned string contains all necessary context variables formatted correctly."
          },
          {
            "id": 3,
            "title": "Integrate Vercel AI SDK and Database Persistence",
            "description": "Implement the API route to orchestrate the safety check, generate the plan using GPT-4o, and save the complex structured result to the database via Prisma.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/app/api/analyze/route.ts` with `maxDuration = 300`. First, call the Safety Service (Task 5). If safe, invoke `generateObject` using the schema from Subtask 1 and prompt from Subtask 2. Parse the result and use a Prisma transaction to save the `TreatmentPlan` and nested relations (goals, interventions) to the database. Handle errors and timeouts gracefully.",
            "status": "done",
            "testStrategy": "Integration test: Mock the OpenAI API response and the Safety Service. Call the endpoint with a sample transcript payload. Verify that the API returns 200 and that the data is correctly persisted in the test database."
          }
        ]
      },
      {
        "id": 7,
        "title": "Develop Dashboard and Session List UI",
        "description": "Build the main therapist dashboard to list clients and sessions, integrating with the database.",
        "details": "1. Create `src/app/dashboard/page.tsx`.\n2. Fetch sessions and users using Prisma (server components).\n3. Display a list of 'Recent Sessions' with status indicators (Processed, Pending).\n4. Implement the 'Upload Session' button triggering the file upload flow (Task 3) + Transcribe (Task 4) + Analyze (Task 6) sequence.\n5. Use shadcn/ui components (Table, Button, Card) for layout.",
        "testStrategy": "Verify the dashboard loads real data from the seeded DB. Verify the upload button initiates the chain of API calls.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Server-Side Session Data Fetching",
            "description": "Develop the necessary server actions and database queries to retrieve user sessions for the dashboard with proper sorting and filtering.",
            "dependencies": [],
            "details": "Create a Server Action (e.g., `getDashboardSessions`) to query `prisma.session.findMany`. Ensure the query includes filtering by the logged-in therapist, sorting by creation date (descending), and basic pagination support. Fetch related `Client` or `User` data to display names alongside sessions. Define TypeScript interfaces for the return data.",
            "status": "done",
            "testStrategy": "Write an integration test calling the server action against a seeded test database to verify it returns the expected number of sessions and correct ordering."
          },
          {
            "id": 2,
            "title": "Build Dashboard UI and Upload Workflow",
            "description": "Create the visual interface for the dashboard and implement the client-side logic for the multi-step session upload pipeline.",
            "dependencies": [
              1
            ],
            "details": "Implement `src/app/dashboard/page.tsx` using shadcn/ui Table and Card components. Integrate the data fetching from Subtask 1. Develop the 'Upload Session' button component which triggers an async chain: get presigned URL (Task 3), upload to S3, call transcription API (Task 4), then call analysis API (Task 6). Manage local state to show progress indicators (Uploading... -> Transcribing... -> Analyzing...).",
            "status": "done",
            "testStrategy": "Manually test the full flow: Click upload, select file, and verify the UI updates through each stage (upload, transcribe, analyze) culminating in a refresh of the session list."
          }
        ]
      },
      {
        "id": 8,
        "title": "Develop Dual-View Plan Component",
        "description": "Create the UI for viewing the generated plan, toggling between Therapist (Clinical) and Client (Empathetic) views.",
        "details": "1. Create `src/components/plan/DualViewPlan.tsx`.\n2. Use Zustand to manage local state for the view mode (Therapist vs Client).\n3. Render 'Therapist View': SOAP Note style, clinical goals, risk score, ICD codes placeholders.\n4. Render 'Client View': Warm summary, emoji-enhanced goals, simplified language.\n5. Include the mandatory AI disclaimer footer in both views.\n6. Implement the 'Safety Alert' banner if riskScore is HIGH.",
        "testStrategy": "Manually verify toggling between views changes the displayed content. check that the disclaimer is always visible.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Develop Therapist View Component",
            "description": "Create the clinical presentation layer for the treatment plan, focusing on professional data rendering.",
            "dependencies": [],
            "details": "Create `src/components/plan/TherapistView.tsx`. Implement the layout to display structured SOAP notes (Subjective, Objective, Assessment, Plan). Include sections for Clinical Goals, ICD-10 code placeholders, and a visual indicator for the Risk Score. Ensure the typography and spacing reflect a professional, data-dense clinical dashboard.",
            "status": "done",
            "testStrategy": "Render the component with mock clinical data and verify that SOAP sections and risk scores appear correctly."
          },
          {
            "id": 2,
            "title": "Develop Client View and Parent Container",
            "description": "Build the patient-facing view and the main container that manages view switching and shared elements.",
            "dependencies": [
              1
            ],
            "details": "Create `src/components/plan/ClientView.tsx` using warm, accessible language and emoji-enhanced goal lists. Create the parent component `src/components/plan/DualViewPlan.tsx`. Implement a local Zustand store or React state to toggle between the Therapist and Client components. Add the conditional 'Safety Alert' banner for high-risk plans and the mandatory fixed AI disclaimer footer visible in both views.",
            "status": "done",
            "testStrategy": "Test the toggle functionality ensures only one view is visible at a time. Verify the disclaimer footer is present in both modes."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Simulation & Demo Data Script",
        "description": "Create the 'Magic Button' and audio generation script to simulate sessions for demo purposes.",
        "details": "1. Implement `scripts/generate-audio.ts` to generate synthetic audio using OpenAI TTS and ffmpeg (as per PRD).\n2. In the UI, add a 'Generate Random Session' button.\n3. Connect this button to a server action that uses GPT-4o to generate a random transcript text directly (bypassing audio upload for speed) or uses a pre-seeded audio file.\n4. Ensure this flow populates the database with a new session and plan.",
        "testStrategy": "Run the script to generate an audio file. Click the magic button in the UI and verify a new plan appears in the dashboard.",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Audio Generation Script",
            "description": "Create a standalone TypeScript script to generate synthetic audio files for testing purposes using OpenAI TTS.",
            "dependencies": [],
            "details": "Develop `scripts/generate-audio.ts`. Use `openai.audio.speech.create` to convert text input into MP3 format. Incorporate `fluent-ffmpeg` if necessary to merge multiple audio chunks for longer sessions. Ensure the script can be run via CLI to produce assets.",
            "status": "done",
            "testStrategy": "Run `tsx scripts/generate-audio.ts` and verify a valid MP3 file is created in the output directory."
          },
          {
            "id": 2,
            "title": "Create Demo Session Server Action",
            "description": "Implement a server action to generate realistic synthetic transcript text using GPT-4o.",
            "dependencies": [],
            "details": "Create `src/app/actions/generateDemoSession.ts`. Construct a prompt for GPT-4o to generate a dialogue between a therapist and a client (approx. 500-1000 words). This bypasses the actual transcription process for speed during demos.",
            "status": "done",
            "testStrategy": "Invoke the server action from a test harness and assert that it returns a coherent string containing a dialogue."
          },
          {
            "id": 3,
            "title": "Integrate Plan Generation for Demo Data",
            "description": "Connect the demo session generation flow to the database and the plan generation logic.",
            "dependencies": [
              2
            ],
            "details": "Within the server action, create a new `Client` and `Session` record in Prisma. Pass the synthetic transcript to the logic defined in Task 6 (Plan Generation) to create a corresponding `TreatmentPlan` record automatically.",
            "status": "done",
            "testStrategy": "Run the demo generation flow and query the database to verify a Session exists with a linked TreatmentPlan."
          },
          {
            "id": 4,
            "title": "Develop Magic Button UI Component",
            "description": "Create the frontend button component to trigger the random session generation.",
            "dependencies": [
              2,
              3
            ],
            "details": "Add a 'Generate Random Session' button to the Dashboard header. Connect it to the server action. Implement a loading state (spinner) while the LLM generates data, and handle success/error notifications using toast messages.",
            "status": "done",
            "testStrategy": "Click the button in the UI, observe the loading state, and verify the UI updates without a full page reload."
          },
          {
            "id": 5,
            "title": "Finalize Demo Flow & Placeholder Assets",
            "description": "Ensure the demo session includes placeholder audio links and triggers correct cache revalidation.",
            "dependencies": [
              3,
              4
            ],
            "details": "Since the demo bypasses upload, set the `audioUrl` in the database to a pre-seeded S3 public URL (generic audio) or handle nulls gracefully in the audio player. execute `revalidatePath` to refresh the dashboard list immediately.",
            "status": "done",
            "testStrategy": "Generate a demo session, then attempt to 'play' the audio in the session detail view to ensure the player does not crash."
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Version Control and Plan Editing",
        "description": "Allow therapists to edit plans and save new versions.",
        "details": "1. Make the plan fields editable in the UI (Textareas, Input fields).\n2. Create an endpoint `POST /api/plans/[id]/update`.\n3. On save, create a new `PlanVersion` record in Prisma with a snapshot of the content.\n4. Update the main `TreatmentPlan` record with the new values.\n5. (Bonus) Add a simple 'History' tab showing timestamps of previous versions.",
        "testStrategy": "Edit a plan, save it, and check the database to ensure a new PlanVersion row was created and the main TreatmentPlan was updated.",
        "priority": "low",
        "dependencies": [
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Backend Plan Versioning and Update Endpoint",
            "description": "Develop the API route and Prisma logic to snapshot the current plan into a history table before updating the active record.",
            "dependencies": [],
            "details": "Create `POST /api/plans/[id]/update` with Zod validation. Use a Prisma transaction to ensure data integrity: 1. Fetch the current `TreatmentPlan`. 2. Create a new `PlanVersion` record populated with the current plan's data. 3. Update the `TreatmentPlan` record with the new payload from the request. Handle database errors gracefully.",
            "status": "done",
            "testStrategy": "Integration test: Send a POST request with updated fields. Verify in the database that a new `PlanVersion` row exists with the original data and the `TreatmentPlan` row contains the new data."
          },
          {
            "id": 2,
            "title": "Develop Frontend Plan Editing Interface and History Tab",
            "description": "Create the user interface for toggling edit mode, modifying plan fields, and viewing the save history.",
            "dependencies": [
              1
            ],
            "details": "Update the Plan Detail page to include an 'Edit' toggle. Use React state to switch between display text and form inputs (Textarea/Input). Implement the save handler to call the update API. Additionally, implement a simple 'History' tab that fetches and lists `PlanVersion` timestamps associated with the plan ID.",
            "status": "done",
            "testStrategy": "UI Test: Open a plan, click 'Edit', modify a text field, and click 'Save'. Mock the API response to success and verify the UI reverts to view mode displaying the updated text."
          }
        ]
      },
      {
        "id": 11,
        "title": "Setup Project Foundation & Infrastructure",
        "description": "Initialize the Next.js application with the required stack (Tailwind v4, shadcn/ui, Zustand), configure AWS services (RDS, Cognito, S3), and set up the Prisma database schema to support the dual-perspective treatment plan data model.",
        "details": "1. **Framework Setup**: Initialize a Next.js 16 (App Router) project with TypeScript.\n2. **Styling**: Configure Tailwind CSS v4 and install `shadcn/ui` components (Button, Card, Input, Textarea, Dialog/Modal).\n3. **State Management**: Install and set up Zustand for global state management (Plan Editor state).\n4. **Database & ORM**:\n   - Set up a local PostgreSQL instance or connect to AWS RDS (db.t3.micro).\n   - Initialize Prisma (`npx prisma init`).\n   - Define the schema in `prisma/schema.prisma` exactly as specified in the PRD (Models: User, Session, TreatmentPlan, PlanVersion).\n   - Run initial migration (`npx prisma migrate dev --name init`).\n5. **AWS Integration**:\n   - Configure `aws-config.ts` in `src/lib` to load credentials from environment variables for Cognito, S3, and RDS access.\n   - Create a basic auth wrapper using AWS Cognito (or a mock for local dev if Cognito isn't ready).\n6. **Environment Variables**: Create `.env.local` template with placeholders for AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION, COGNITO_USER_POOL_ID, DATABASE_URL, OPENAI_API_KEY.",
        "testStrategy": "1. Verify the Next.js app builds and runs locally.\n2. Check that Prisma generates the client and can connect to the database.\n3. Validate that the `schema.prisma` accurately reflects the User, Session, and TreatmentPlan relations.\n4. Verify Tailwind and shadcn components render correctly on a sample page.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Core AI Pipeline & API Routes",
        "description": "Develop the backend API routes for file upload, transcription (Whisper), safety analysis, and treatment plan generation (GPT-4o) with strict timeout configurations.",
        "details": "1. **S3 Upload Flow**: Create `POST /api/upload-url` to generate pre-signed URLs for audio/video uploads.\n2. **Transcription Service**: Implement `POST /api/transcribe`. \n   - Use `openai.audio.transcriptions.create` (Whisper v2/v3).\n   - Set `export const maxDuration = 300;` to handle long running processes.\n3. **Safety & Generation Service**: Implement `POST /api/analyze`.\n   - **Safety Layer**: Implement a check using Regex for keywords and a lightweight GPT-4o-mini call to classify risk. Return a 'High Risk' flag if triggered.\n   - **Plan Generation**: If safe, call GPT-4o with the `TreatmentPlanSchema` (Zod) to generate the JSON output (Clinical Goals, Client Goals, etc.). ensure `response_format: { type: \"json_object\" }` is used or Vercel AI SDK's `generateObject`.\n4. **Data Persistence**: Update the route to save the generated Transcript to the `Session` table and the resulting JSON to the `TreatmentPlan` table via Prisma.\n5. **Utilities**: Implement `src/lib/openai.ts` for shared client configuration.",
        "testStrategy": "1. Test `/api/upload-url` generates a valid S3 URL.\n2. Mock OpenAI responses to test `/api/transcribe` and `/api/analyze` flow without incurring costs.\n3. Validate that the Zod schema correctly parses the AI output.\n4. Verify that `maxDuration` is set to prevent Vercel timeouts.\n5. Upload a dummy audio file (or use the synthetic script output) and verify the end-to-end flow results in a DB entry.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Develop Dual-View UI & Dashboard",
        "description": "Build the frontend interfaces for the Therapist Dashboard, including the Session list, file upload, and the interactive dual-view Plan Editor.",
        "details": "1. **Dashboard Layout**: Create a layout with a sidebar and main content area using the initialized `shadcn` components.\n2. **Session List**: Fetch and display sessions from Prisma (`GET /api/clients/:id/plans`).\n3. **Upload Component**: Create a drag-and-drop zone that hits `/api/upload-url` then uploads directly to S3, showing progress.\n4. **Plan Editor (Dual View)**:\n   - Create a toggle/tab system to switch between 'Clinical View' (SOAP notes, technical terms) and 'Client View' (Empathetic summary, emoji goals).\n   - Bind the editor inputs to the Zustand store.\n   - Implement the 'Safety Alert' banner component that triggers if `riskScore` is HIGH.\n   - Add the required disclaimer footer: 'Generated by AI Assistant...'.\n5. **Magic Button**: Add a button to trigger the simulation flow (call `/api/generate` with a flag or mock data seed) for demo purposes.",
        "testStrategy": "1. Verify file upload UI updates progress and handles errors (e.g., >25MB).\n2. Test the toggle between Clinical and Client views ensures data consistency.\n3. visually verify the 'Safety Alert' appears when risk is high.\n4. Check that the Plan Editor correctly loads data from the `TreatmentPlan` model.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Transcript View Tab in Dual-View Plan Component",
            "description": "Extend the existing Dual-View Plan component to include a third tab for the raw session transcript alongside the Clinical and Client views. [Updated: 11/24/2025]",
            "dependencies": [],
            "details": "Modify `src/components/plan/DualViewPlan.tsx` to add a 'Transcript' tab using the existing tabs UI pattern. Fetch or receive the raw transcript string (e.g., from the `Session` object via props or store). Display the transcript in a scrollable text area or read-only editor. Ensure it integrates seamlessly with the existing `viewMode` state (switching between Clinical, Client, and Transcript).",
            "status": "done",
            "testStrategy": "Verify that clicking the 'Transcript' tab displays the mock or real transcript text and that switching back to other tabs preserves state."
          }
        ]
      },
      {
        "id": 14,
        "title": "Database Schema Refactoring for Patient-Centric Model",
        "description": "Refactor the Prisma schema to introduce the Patient model and update relationships for Session and TreatmentPlan to shift from a session-centric to a patient-centric architecture.",
        "details": "1. Modify `prisma/schema.prisma`:\n   - Create `model Patient` with fields: `id` (UUID, default), `name` (String), `status` (Enum: ACTIVE, ARCHIVED), `clinicianId` (String), `createdAt`, `updatedAt`.\n   - Add relation: `Patient` belongs to `User` (clinician).\n   - Update `Session`: Remove `userId` relation, add `patientId` (relation to Patient).\n   - Update `TreatmentPlan`: Remove `sessionId` relation, add `patientId` (unique relation to Patient). Keep `PlanVersion` relation.\n2. Create a migration file using `npx prisma migrate dev --name introduce_patient_model`.\n3. Update `src/lib/db.ts` or any seed scripts (`prisma/seed.ts`) to populate initial `Patient` data and link existing sessions/plans if data preservation is needed (or clear db for dev).\n4. Regenerate Prisma Client.",
        "testStrategy": "Run `npx prisma validate`. Verify the database schema in a local Postgres instance. Create a unit test in `tests/db.test.ts` that creates a User, then a Patient, then a Session linked to that Patient, ensuring referential integrity.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Patient Management UI (List and Detail Views)",
        "description": "Create the frontend pages for listing patients and viewing patient details, leveraging the new database schema.",
        "details": "1. Create `src/app/patients/page.tsx`:\n   - Fetch patients for the logged-in user using a server action `getPatients`.\n   - Display a table with columns: Name, Status, Last Session Date, Risk Score.\n   - Add 'Add Patient' button triggering a modal/form to create a new patient (server action `createPatient`).\n2. Create `src/app/patients/[id]/page.tsx`:\n   - Fetch patient details including relation to `TreatmentPlan` and `Session[]`.\n   - Implement a Tabbed interface (Overview, Treatment Plan, Sessions).\n   - **Tab 1 (Overview):** Display static demographics/stats.\n   - **Tab 2 (Treatment Plan):** Display the current active plan JSON/Fields. Add a 'History' button (placeholder for now).\n   - **Tab 3 (Sessions):** List past sessions with links/audio players.\n3. Ensure navigation is updated in the main layout/sidebar.",
        "testStrategy": "Manual testing: specific user logs in, adds a patient, sees it in the list. Click patient, verify details page loads. Unit test the `getPatients` and `createPatient` server actions using mocks.",
        "priority": "high",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Patient Server Actions",
            "description": "Create server actions for fetching the patient list, fetching single patient details with relations, and creating new patients.",
            "dependencies": [],
            "details": "Create `src/actions/patients.ts` (or similar location based on convention). Implement `getPatients(userId: string)` to return a list of patients with fields: id, name, status, lastSessionDate, riskScore. Implement `getPatientById(id: string)` that includes `TreatmentPlan` (current) and `Session` relations. Implement `createPatient(data: PatientInput)` which validates input and creates a record in Prisma. Ensure error handling and revalidation of paths.",
            "status": "done",
            "testStrategy": "Unit test the actions using a mock Prisma client to verify correct data retrieval and creation logic."
          },
          {
            "id": 2,
            "title": "Create Patient List Page and Add Modal",
            "description": "Develop the main patients page displaying a table of patients and a modal for adding new ones.",
            "dependencies": [
              1
            ],
            "details": "Create `src/app/patients/page.tsx`. Use the `getPatients` server action to fetch data. Render a responsive table showing patient Name, Status, Last Session Date, and Risk Score. Implement a 'Add Patient' button that opens a Dialog/Modal containing a form (Name, DOB, initial status). On form submission, call `createPatient` and refresh the list. Update the main application sidebar/navigation to include a link to `/patients`.",
            "status": "done",
            "testStrategy": "Manual verification: Navigate to /patients, verify the list loads. Open the 'Add Patient' modal, submit a new patient, and verify the list updates dynamically."
          },
          {
            "id": 3,
            "title": "Develop Patient Detail View with Tabs",
            "description": "Build the dynamic patient detail page with tabs for Overview, Treatment Plan, and Session History.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `src/app/patients/[id]/page.tsx`. Fetch patient data using `getPatientById`. Implement a tabbed interface using a UI component (e.g., Tabs from shadcn/ui). \n- **Overview Tab:** Display demographics and aggregate stats.\n- **Treatment Plan Tab:** Render the most recent active Treatment Plan details (JSON/Fields).\n- **Sessions Tab:** List associated sessions with links to their details or audio players.\nEnsure proper 404 handling if the patient is not found.",
            "status": "done",
            "testStrategy": "Manual verification: Click a patient from the list, verify redirection to `/patients/[id]`. Check that all three tabs render correct data associated with that specific patient ID."
          }
        ]
      },
      {
        "id": 16,
        "title": "Update Analysis Service for Context-Aware AI Pipeline",
        "description": "Refactor the AI analysis pipeline to use the Patient's existing treatment plan and history as context when processing new sessions.",
        "details": "1. Modify `src/lib/services/analysis-service.ts` (or equivalent):\n   - Update `processSession` signature to accept `patientId`.\n2. In `processSession`:\n   - Fetch the *active* `TreatmentPlan` for the patient.\n   - Fetch the last 3 `Session` transcripts for this patient.\n3. Update `src/lib/ai/prompts.ts`:\n   - Create a new system prompt that injects: \"Current Plan: [JSON]\", \"Recent History: [Summaries]\", \"New Transcript: [Text]\".\n   - Instruct LLM to *update* the plan rather than generate from scratch (mark goals complete, update risk, etc).\n4. Save logic:\n   - Update `TreatmentPlan` record in DB.\n   - Create a new `PlanVersion` record with the snapshot of the new plan.",
        "testStrategy": "Integration test: specific patient with an existing plan. Feed a mock transcript implying a goal was met. Verify the returned plan updates the goal status to 'completed' and creates a new version in the DB.",
        "priority": "medium",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update AI Prompts for Context-Aware Plan Generation",
            "description": "Refactor prompt generation logic to accept and utilize patient context, including current plan state and historical session summaries.",
            "dependencies": [],
            "details": "Modify `src/lib/ai/prompts.ts`. Create a new interface `AnalysisContext` containing `currentPlan: string | null`, `recentHistory: string[]`, and `newTranscript: string`. Implement a function `generateContextAwarePrompt(context: AnalysisContext)` that constructs a system message instructing the LLM to act as an 'updater' of the existing plan rather than a creator from scratch. The prompt should explicitly ask for updates to goal statuses and risk assessments based on the new transcript.",
            "status": "done",
            "testStrategy": "Unit test the prompt generator function with mock context data to verify the output string contains the expected sections (Current Plan, History, Transcript)."
          },
          {
            "id": 2,
            "title": "Refactor Analysis Service to Fetch Patient Context",
            "description": "Update the analysis service to retrieve the necessary patient data (active plan and session history) before processing the new session.",
            "dependencies": [
              1
            ],
            "details": "In `src/lib/services/analysis-service.ts`, modify `processSession` to accept `patientId` and `transcript`. Use Prisma to fetch: 1) The active `TreatmentPlan` for this `patientId` (if exists). 2) The last 3 `Session` records for this `patientId` (ordered by date desc). Pass these retrieved entities into the prompt generation logic created in subtask 1.",
            "status": "done",
            "testStrategy": "Integration test using a mocked Prisma client to verify that `processSession` correctly queries for the plan and recent sessions using the provided `patientId`."
          },
          {
            "id": 3,
            "title": "Implement Differential Plan Update Logic",
            "description": "Handle the LLM response to update the existing TreatmentPlan record and version history instead of creating a new unconnected plan.",
            "dependencies": [
              2
            ],
            "details": "Inside `src/lib/services/analysis-service.ts`, update the persistence logic. If an existing plan was found: 1) Update the `TreatmentPlan` record with the new JSON data (goals, diagnosis, etc.). 2) Create a new `PlanVersion` linked to this plan containing the snapshot. If no plan existed (first session), maintain the existing creation logic but associate it with the `patientId`. Ensure transactional integrity using `prisma.$transaction`.",
            "status": "done",
            "testStrategy": "Integration test: Seed a patient with an existing plan. Run the service. Assert that the `TreatmentPlan` ID remains the same but its content is updated, and a new `PlanVersion` count is incremented."
          },
          {
            "id": 4,
            "title": "Update API Route for Patient-Aware Analysis",
            "description": "Expose the updated analysis logic through the API layer, handling the new input requirements.",
            "dependencies": [
              3
            ],
            "details": "Modify the API route (likely `src/app/api/analyze/route.ts` or `src/app/api/sessions/route.ts`) to validate the incoming request body for `patientId`. Update the call to `analysisService.processSession` to pass the `patientId`. Ensure proper error handling if the patient does not exist or does not belong to the authenticated clinician.",
            "status": "done",
            "testStrategy": "E2E test via Supertest or HTTP client: POST to the endpoint with a valid `patientId` and transcript. Verify the response includes the updated plan structure and status 200."
          }
        ]
      },
      {
        "id": 17,
        "title": "Enhance Simulation Modal with Patient Context",
        "description": "Upgrade the simulation tool to allow generating sessions based on existing patient data or creating new personas.",
        "details": "1. Update the 'Simulate Session' UI (likely in `src/components/simulation-modal.tsx`):\n   - Add a toggle/select: 'Existing Patient' vs 'New Persona'.\n   - If 'Existing Patient': Dropdown of user's patients.\n2. Modify the simulation API endpoint (`/api/simulate`):\n   - If `patientId` is provided, fetch their `TreatmentPlan` and recent `Session`.\n   - Pass this context to the LLM generating the synthetic transcript (e.g., 'Generate a dialogue where the patient discusses the homework from the previous session in context of their anxiety goals').\n3. Upon 'Save' of simulation, ensure it saves to the correct `patientId` in the DB.",
        "testStrategy": "Select a patient with 'High Anxiety'. Generate a simulation. Verify the generated text mentions anxiety or specific goals from that patient's plan.",
        "priority": "medium",
        "dependencies": [
          15,
          16
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Simulate Session Server Action for Patient Context",
            "description": "Modify the server action responsible for generating simulations to accept a patientId. If provided, fetch the patient's TreatmentPlan and recent sessions to inject specific context into the LLM prompt.",
            "dependencies": [],
            "details": "Update the server action (likely `generateSimulation` or similar) to accept an optional `patientId`. Use Prisma to fetch the `Patient` along with their active `TreatmentPlan` (including diagnosis and goals) and the most recent `Session` summary. Construct a context string (e.g., 'Patient has [diagnosis]. Current goals: [goals]. Last session covered: [summary]') and append it to the system prompt for the LLM. Ensure the action falls back to the 'New Persona' logic if no `patientId` is provided.",
            "status": "done",
            "testStrategy": "Unit test the server action with a mock `patientId`. Verify that the constructed prompt contains the mocked patient's diagnosis and goals."
          },
          {
            "id": 2,
            "title": "Enhance Simulation Modal UI with Patient Selector",
            "description": "Update the Simulation Modal component to include a toggle for 'Existing Patient' vs 'New Persona' and a dropdown to select from the user's patients.",
            "dependencies": [
              1
            ],
            "details": "Modify `src/components/magic-button.tsx` or the specific simulation modal component. Add a state for `simulationType` ('persona' | 'patient'). If 'patient' is selected, render a `<Select>` or `<Combobox>` populated with the user's patients (fetched via a `getPatients` server action). Pass the selected `patientId` to the server action created in subtask 1. Ensure the existing 'persona' input fields are hidden or disabled when 'patient' is selected.",
            "status": "done",
            "testStrategy": "Manual verification: Open modal, toggle to 'Existing Patient', ensure patient list loads. Select a patient and submit, ensuring the `patientId` is passed in the payload."
          },
          {
            "id": 3,
            "title": "Implement Session Saving Logic for Simulated Patients",
            "description": "Ensure that when a simulated session is saved, it is correctly associated with the selected patient in the database.",
            "dependencies": [
              2
            ],
            "details": "Update the 'Save Session' logic (likely in the same server action or a subsequent `saveSession` action). If a `patientId` was associated with the simulation context, ensure the created `Session` record has its `patientId` field set. If it was a generic persona simulation, the current behavior (likely saving without a patient or creating a temporary context) remains. Verify permissions to ensure the user owns the patient record.",
            "status": "done",
            "testStrategy": "End-to-end test: Simulate a session for a specific patient, click save, then check the database (or patient details page) to verify a new Session record exists linked to that patient ID."
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement User Settings and Clinical Preferences",
        "description": "Create a settings page for users to define their clinical modality, which influences the AI generation style.",
        "details": "1. Update `User` model in Prisma (if needed) or just use a JSON field `preferences`.\n2. Create `src/app/settings/page.tsx`:\n   - Form with fields like 'Clinical Modality' (Select: CBT, DBT, Psychodynamic).\n   - Save button calling `updateSettings` server action.\n3. Update the AI Prompt Service (`src/lib/ai/prompts.ts`):\n   - Inject the user's preferred modality into the system prompt (e.g., 'Act as a [CBT] therapist...').",
        "testStrategy": "Set modality to 'CBT'. Run a simulation or analysis. Verify the output style/language reflects CBT principles (e.g., cognitive distortions, homework) vs another style.",
        "priority": "low",
        "dependencies": [
          14
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Update User Model and Create Settings Action",
            "description": "Modify the Prisma schema to add a 'clinicalModality' field to the User model and implement the server action to update it.",
            "dependencies": [],
            "details": "1. Edit `prisma/schema.prisma`: Add `clinicalModality String? @default(\"CBT\")` (or an enum) to the `User` model.\n2. Run `npx prisma db push` or `migrate dev` to apply changes.\n3. Create or update `src/app/actions.ts` (or a dedicated settings action file): Implement `updateUserSettings(modality: string)` which validates the input (CBT, DBT, Psychodynamic, etc.) and updates the user record in the database using `prisma.user.update`.",
            "status": "done",
            "testStrategy": "Call the server action with a specific string (e.g., 'DBT') and verify via Prisma Studio or database query that the user's record is updated correctly."
          },
          {
            "id": 2,
            "title": "Implement Settings Page UI",
            "description": "Create a frontend page allowing users to select and save their preferred clinical modality.",
            "dependencies": [
              1
            ],
            "details": "1. Create `src/app/settings/page.tsx`.\n2. Fetch the current user's settings server-side to populate the initial state.\n3. Build a form using Shadcn UI components (Select, Button, Card) allowing selection of modalities (CBT, DBT, Psychodynamic, ACT).\n4. Wire the 'Save' button to the `updateUserSettings` server action created in the previous task.\n5. Add toast notifications for success/error states.",
            "status": "done",
            "testStrategy": "Navigate to /settings, change the modality to 'Psychodynamic', click Save, reload the page, and verify the selection persists."
          },
          {
            "id": 3,
            "title": "Integrate Modality into AI Prompt Logic",
            "description": "Update the AI prompt construction logic to include the user's clinical modality preference.",
            "dependencies": [
              1
            ],
            "details": "1. Locate the analysis logic (likely in `src/app/api/analyze/route.ts` or `src/lib/ai/prompts.ts`).\n2. Retrieve the user's `clinicalModality` from the database before generating the prompt.\n3. Modify the system prompt construction to inject a directive such as: 'Adopt a ${modality} clinical framework. Use terminology and interventions specific to ${modality}.'\n4. Ensure a fallback (e.g., 'General Integrative Therapy') is used if the preference is null.",
            "status": "done",
            "testStrategy": "Set user modality to 'CBT'. Trigger a plan generation. Inspect the generated plan text for CBT-specific keywords (e.g., 'cognitive distortions', 'automatic thoughts'). Repeat for 'DBT' (checking for 'mindfulness', 'distress tolerance')."
          }
        ]
      },
      {
        "id": 19,
        "title": "Refactor Database Schema for Patient-Centric Architecture",
        "description": "Update the Prisma schema to introduce the `Patient` model and restructure `Session` and `TreatmentPlan` relations to center around the Patient, shifting away from the current session-centric model.",
        "details": "1. Modify `prisma/schema.prisma`:\n   - Define `model Patient` with fields: `id` (UUID), `name` (String), `status` (Enum: ACTIVE, ARCHIVED), `clinicianId` (User relation), `createdAt`, `updatedAt`.\n   - Update `model Session`: Remove direct `userId` relation (optional: keep for history or make nullable/deprecated if strict refactor), add `patientId` (relation to Patient).\n   - Update `model TreatmentPlan`: Remove `sessionId` relation (or make nullable for migration), add `patientId` (unique relation to Patient). Ensure `PlanVersion` relation remains intact.\n   - Update `model User`: Add `patients` relation (Patient[]), add `preferences` (Json?).\n2. Create a database migration using `npx prisma migrate dev --name introduce_patient_model`.\n3. Create a seed script or migration logic to ensure existing sessions are preserved (potentially creating placeholder patients for orphaned sessions if strictly enforcing the new schema constraints, or making fields optional initially).\n4. Update typescript interfaces in `types/index.ts` or generated prisma types to reflect these changes.",
        "testStrategy": "1. Run `npx prisma generate` and verify no type errors in schema definition.\n2. Run the migration locally and verify the database tables are created/updated correctly.\n3. Verify via Prisma Studio or script that a Patient can be created and linked to a User, Session, and TreatmentPlan.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-24T05:53:36.016Z",
      "updated": "2025-11-25T03:32:58.347Z",
      "description": "Tasks for master context"
    }
  }
}