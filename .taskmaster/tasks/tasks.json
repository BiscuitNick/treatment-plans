{
  "master": {
    "tasks": [
      {
        "id": 25,
        "title": "Implement Model Selection and Performance Tracking",
        "description": "Upgrade the application to support GPT-5.1 and advanced TTS models, with user-configurable settings and performance metrics.",
        "status": "done",
        "priority": "medium",
        "dependencies": [
          "24"
        ],
        "details": "1. **Settings Upgrade**: Add `llmModel` (gpt-5.1, gpt-5-mini, gpt-4o) and `ttsModel` (gpt-4o-mini-tts, tts-1) to the User settings.\n2. **Backend Update**: Refactor `audio.ts` and `analysis.ts` to respect these settings. Implement `performance.now()` tracking to measure generation time.\n3. **UI Update**: Display the generation duration on the Audio Generator result card.",
        "testStrategy": "Select 'gpt-5.1' and 'gpt-4o-mini-tts' in settings. Generate audio. Verify the correct models were called (via logs) and the time is displayed.",
        "subtasks": [
          {
            "id": 1,
            "title": "Update Settings Schema and User Interface for Model Configuration",
            "description": "Extend the User settings to support configuration of LLM and TTS models. Update the database schema to include fields for `llmModel` (enums: gpt-5.1, gpt-5-mini, gpt-4o) and `ttsModel` (enums: gpt-4o-mini-tts, tts-1). Modify the Settings UI component to allow users to select these preferences.",
            "dependencies": [],
            "details": "1. Modify `prisma/schema.prisma` (or equivalent schema definition) to add `llmModel` and `ttsModel` to the User model with default values. \n2. Run migrations. \n3. Update the settings form component (likely located in `src/components/settings/` or similar) to include dropdowns for these new fields. \n4. Ensure the update server action saves these new preferences.",
            "status": "done",
            "testStrategy": "Verify schema migration runs successfully. Check that the settings page renders the new dropdowns and successfully saves the selected models to the database."
          },
          {
            "id": 2,
            "title": "Refactor Backend Logic for Dynamic Model Usage and Performance Metrics",
            "description": "Update `audio.ts` and `analysis.ts` server actions to retrieve user preferences and use the selected models for generation. Implement `performance.now()` benchmarking to capture execution time.",
            "dependencies": [
              1
            ],
            "details": "1. In `src/app/actions/analysis.ts`, fetch the user's `llmModel` setting and pass it to the OpenAI API call. \n2. In `src/app/actions/audio.ts`, fetch the user's `ttsModel` setting and use it for speech generation. \n3. Wrap the generation logic in both files with `performance.now()` start and end markers. \n4. Calculate the duration in milliseconds and return this metadata along with the generated content.",
            "status": "done",
            "testStrategy": "Unit test the actions with different user settings mock data to ensure correct model parameters are sent to the AI provider. Verify that the returned object includes a `duration` field."
          },
          {
            "id": 3,
            "title": "Display Generation Performance Metrics in UI",
            "description": "Update the Audio Generator result component to display the time taken for generation, providing feedback on model performance.",
            "dependencies": [
              2
            ],
            "details": "1. Locate the Audio Generator result card component (likely in `src/components/audio/` or `src/app/audio/`). \n2. Update the component's props interface to accept the `duration` or performance data returned from the backend. \n3. Render a small badge or text element (e.g., 'Generated in 1.2s') on the card. \n4. Handle cases where duration might be missing for legacy data.",
            "status": "done",
            "testStrategy": "Generate a new audio clip via the UI and confirm that the duration badge appears on the result card."
          }
        ]
      },
      {
        "id": 26,
        "title": "Update Prisma Schema with New Enums and Models",
        "description": "Update the Prisma schema to include `SuggestionStatus` and `GoalStatus` enums, and create `PlanSuggestion` and `GoalHistory` models. Update `TreatmentPlan`, `PlanVersion`, and `Session` models to support new relations.",
        "details": "1. Modify `prisma/schema.prisma`.\n2. Add `enum SuggestionStatus { PENDING, APPROVED, MODIFIED, REJECTED }`.\n3. Update `enum GoalStatus` to include: ACTIVE, IN_PROGRESS, COMPLETED, MAINTAINED, DEFERRED, DISCONTINUED.\n4. Define `model PlanSuggestion` with fields: `id`, `treatmentPlanId`, `sessionId`, `status`, `suggestedChanges` (Json), `sessionSummary`, `progressNotes`, `reviewedAt`, `reviewedBy`, `therapistNotes`, `createdAt`.\n5. Define `model GoalHistory` with fields: `id`, `treatmentPlanId`, `goalId`, `previousStatus`, `newStatus`, `changedAt`, `changedBy`, `reason`, `sessionId`.\n6. Update `TreatmentPlan` to include `lastReviewedAt`, `nextReviewDue`, and relations to suggestions and history.\n7. Update `PlanVersion` to include `changeType`, `changeSummary`, `suggestionId`.\n8. Update `Session` to include `progressNote` and relation to `PlanSuggestion`.",
        "testStrategy": "Run `npx prisma format` to validate syntax. Generate a migration using `npx prisma migrate dev --name add_suggestion_lifecycle` and verify it creates tables successfully in a local DB.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Define Types and Interfaces for Suggested Changes",
        "description": "Create TypeScript interfaces to strictly type the JSON structures used in `PlanSuggestion` and API responses.",
        "details": "1. Create `src/types/suggestion.ts`.\n2. Define `interface SuggestedChanges` matching the PRD (goalUpdates, newGoals, interventionsUsed, suggestedInterventions, homeworkUpdate, riskAssessment).\n3. Define `interface GoalUpdate` and `interface NewGoal`.\n4. Export these types for use in backend services and frontend components to ensure type safety across the suggestion workflow.",
        "testStrategy": "Review types against PRD requirements. Ensure they compile without errors when imported into a dummy file.",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Refactor AI Prompt for Incremental Analysis",
        "description": "Create a new prompt template that instructs the AI to analyze a session against an existing plan and output structured `SuggestedChanges` instead of a full plan rewrite.",
        "details": "1. Locate existing AI service (e.g., `src/lib/ai/` or similar).\n2. Create a new prompt function `generateSuggestionPrompt(currentPlan, transcript)`.\n3. Implement the prompt structure defined in PRD Section 8.2.\n4. Ensure the output format instruction enforces the `SuggestedChanges` JSON schema defined in Task 27.\n5. Explicitly instruct the AI to provide a session summary and progress notes separately.",
        "testStrategy": "Unit test the prompt generation function. Run a test call with a mock transcript and plan to verify the AI returns the expected JSON structure.",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Suggestion Generation Service",
        "description": "Build the backend service logic to handle session analysis and create a `PlanSuggestion` record.",
        "details": "1. Create a service function `createSessionAnalysis(sessionId: string)`.\n2. Fetch the session (transcript) and the `currentContent` of the associated `TreatmentPlan`.\n3. Call the AI provider with the prompt from Task 28.\n4. Parse the AI response.\n5. Store the result in the `PlanSuggestion` table with status `PENDING`.\n6. Do NOT update the `TreatmentPlan` or create a `PlanVersion` yet.",
        "testStrategy": "Integration test: Call the service with a valid session ID. Verify a new `PlanSuggestion` record is created in the DB with correct JSON content.",
        "priority": "high",
        "dependencies": [
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Create API Endpoint for Session Analysis",
        "description": "Expose the suggestion generation logic via an API endpoint.",
        "details": "1. Create `POST /api/sessions/[id]/analyze`.\n2. Validate the session exists and belongs to the user's patient.\n3. Call the service from Task 29.\n4. Return the created `suggestion`, `sessionSummary`, and `suggestedChanges` in the response.\n5. Ensure proper error handling for AI failures or missing transcripts.",
        "testStrategy": "Use Postman or `curl` to hit the endpoint. Verify 200 OK response and correct JSON body. Verify DB state.",
        "priority": "medium",
        "dependencies": [
          29
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Plan Merging Logic",
        "description": "Create a utility to apply `SuggestedChanges` to a `TreatmentPlan`'s current content JSON.",
        "details": "1. Create `src/lib/plans/merger.ts`.\n2. Implement `applyChanges(currentPlan: any, changes: SuggestedChanges)`.\n3. Logic: Update status of existing goals based on `goalUpdates`. Append `newGoals`. Update interventions and risk assessment.\n4. Ensure this function is pure and deterministic for testing purposes.",
        "testStrategy": "Unit tests with mock data: Pass a plan and a set of changes, assert the output plan has the expected updates (e.g., goal status changed, new goal added).",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Suggestion Approval Endpoint",
        "description": "Create the API endpoint to approve a suggestion, apply changes, and save the new plan version.",
        "details": "1. Create `POST /api/suggestions/[id]/approve`.\n2. Input: `modifications` (optional overrides) and `therapistNotes`.\n3. Transactional steps:\n   a. Update `PlanSuggestion` status to `APPROVED` or `MODIFIED`.\n   b. Retrieve current plan.\n   c. Merge changes using logic from Task 31 (applying modifications if present).\n   d. Create new `PlanVersion` with change type `SESSION_UPDATE`.\n   e. Update `TreatmentPlan` `currentContent`.\n   f. Create `GoalHistory` records for changed goals.\n4. Return the updated plan.",
        "testStrategy": "Integration test: Approve a pending suggestion. Verify `TreatmentPlan` is updated, `PlanVersion` is created, `PlanSuggestion` is closed, and `GoalHistory` is populated.",
        "priority": "high",
        "dependencies": [
          31,
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Implement Suggestion Rejection Endpoint",
        "description": "Create the API endpoint to reject a suggestion.",
        "details": "1. Create `POST /api/suggestions/[id]/reject`.\n2. Input: `reason`.\n3. Update `PlanSuggestion` status to `REJECTED`.\n4. Save `therapistNotes` with the rejection reason.\n5. Do not modify the `TreatmentPlan`.",
        "testStrategy": "Integration test: Reject a suggestion. Verify status update in DB and ensure `TreatmentPlan` remains unchanged.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Create API for Plan Diff and History",
        "description": "Endpoints to retrieve diffs and goal history for the frontend.",
        "details": "1. Create `GET /api/plans/[id]/diff?suggestionId=...`.\n   - Logic: Compare current plan vs. suggestion. Return structured diff.\n2. Create `GET /api/plans/[id]/goal-history`.\n   - Logic: Query `GoalHistory` table joined with `PlanVersion` or `Session` info if needed.\n   - Group by `goalId`.",
        "testStrategy": "Test with a plan that has history. Verify the diff endpoint correctly identifies changed fields. Verify history endpoint returns chronological list of changes.",
        "priority": "medium",
        "dependencies": [
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Frontend: Suggestion Review Panel Component",
        "description": "Build the UI to allow therapists to review AI suggestions.",
        "details": "1. Create `SuggestionReviewPanel.tsx`.\n2. Fetch data from `/api/sessions/[id]/analyze` (or load existing suggestion).\n3. Display 'Session Summary' and 'Risk Assessment' changes.\n4. Display 'Goal Updates' with current vs. suggested status.\n5. Display 'New Goals'.\n6. Include inputs for 'Therapist Notes'.",
        "testStrategy": "Storybook or component test. Render with mock suggestion data. Verify all sections display correctly.",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 36,
        "title": "Frontend: Diff View and Modification UI",
        "description": "Enhance the review panel to support modifying suggestions before approval.",
        "details": "1. Implement a 'Edit' mode for suggested changes in `SuggestionReviewPanel`.\n2. Allow toggling individual goal updates (accept/reject specific items).\n3. Allow editing text of new goals or rationale.\n4. Maintain a local state object of the 'final' suggestion payload to send to the approve endpoint.",
        "testStrategy": "User interaction test. Modify a suggested goal status. Verify the payload prepared for submission reflects the manual change.",
        "priority": "high",
        "dependencies": [
          35
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Frontend: Integrate Approval Actions",
        "description": "Connect the Review Panel to the Approve/Reject APIs.",
        "details": "1. Implement 'Approve All', 'Approve with Changes', and 'Reject' buttons.\n2. On 'Approve', call `POST /api/suggestions/[id]/approve` with the payload.\n3. On 'Reject', prompt for a reason, then call `POST /api/suggestions/[id]/reject`.\n4. On success, redirect to the updated Plan View or show a success toast.",
        "testStrategy": "E2E test or manual verification. Go through the flow of generating a suggestion, modifying it, and approving it. Verify the UI updates to show the new plan version.",
        "priority": "high",
        "dependencies": [
          36,
          32,
          33
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 38,
        "title": "Frontend: Goal Progress Timeline",
        "description": "Create a visualization of goal status changes over time.",
        "details": "1. Create `GoalTimeline.tsx`.\n2. Fetch data from `/api/plans/[id]/goal-history`.\n3. Render a vertical or horizontal timeline for each goal.\n4. Show status nodes (Active -> In Progress -> Completed).\n5. Annotate nodes with dates and session IDs.",
        "testStrategy": "Render with mock history data covering multiple months. Verify nodes are sorted chronologically and status colors match the enum.",
        "priority": "medium",
        "dependencies": [
          34
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 39,
        "title": "Frontend: Update Plan History View",
        "description": "Update the existing Plan History/Versions page to support the new versioning model.",
        "details": "1. Modify the existing versions list to show `changeSummary` and `changeType`.\n2. Add badges for 'Session Update', 'Manual Edit', '90 Day Review'.\n3. Add a 'View Diff' button between versions (reusing the diff logic if possible, or simple JSON diff).",
        "testStrategy": "Check the history page for a plan with multiple versions. Verify the metadata (summary, type) is visible.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 40,
        "title": "Backend: 90-Day Review Logic",
        "description": "Implement logic to calculate and flag 90-day reviews.",
        "details": "1. Update `TreatmentPlan` model to include `nextReviewDue` (if not done in Task 26).\n2. Create a utility to check for due reviews (e.g., `currentDate > nextReviewDue`).\n3. Create endpoint `GET /api/dashboard/reviews-due` to list patients requiring review.\n4. When a plan is approved/created, automatically set `nextReviewDue = now + 90 days` (unless overridden).",
        "testStrategy": "Unit test date calculation. Integration test the endpoint with seeded data containing overdue plans.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 41,
        "title": "Frontend: 90-Day Review Dashboard Widget",
        "description": "Add a widget to the therapist dashboard showing plans due for review.",
        "details": "1. Create `ReviewsDueWidget.tsx`.\n2. Fetch from `/api/dashboard/reviews-due`.\n3. specific list of patients with 'Days Overdue' or 'Due In X Days'.\n4. Link to a 'Start Review' page (which is essentially a comprehensive edit mode).",
        "testStrategy": "Render widget. Verify it displays the correct count and links to the correct patient plans.",
        "priority": "medium",
        "dependencies": [
          40
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 42,
        "title": "Frontend: Patient Portal Progress View",
        "description": "Create a simplified progress view for the patient.",
        "details": "1. Create `PatientProgressView.tsx`.\n2. Use a read-only version of `GoalTimeline`.\n3. Show 'Your Journey' section highlighting major milestones (Completed goals).\n4. Filter out clinical notes or internal rationale; show only descriptions and status.",
        "testStrategy": "Verify the view as a patient user. Ensure sensitive fields (therapist internal notes) are NOT displayed.",
        "priority": "low",
        "dependencies": [
          38
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 43,
        "title": "End-to-End Workflow Validation",
        "description": "Perform a full system test of the new lifecycle.",
        "details": "1. Upload a session audio/transcript.\n2. Verify suggestion generation.\n3. Review and modify the suggestion as a therapist.\n4. Approve the suggestion.\n5. Verify the plan is updated, version is incremented, and history is logged.\n6. Check the 90-day review calculation.\n7. Check the patient portal view.",
        "testStrategy": "Manual QA or automated Cypress/Playwright flow covering the entire 'Happy Path'.",
        "priority": "medium",
        "dependencies": [
          37,
          39,
          41,
          42
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 44,
        "title": "Update Database Schema for Sessions and Patients",
        "description": "Modify the Prisma schema to include new fields for Patient metadata and Session timing.",
        "details": "Update `prisma/schema.prisma`:\n1. Add `age` (Int?), `gender` (String?), `diagnosis` (Text?), and `notes` (Text?) to the `Patient` model.\n2. Add `sessionDate` (DateTime?) and `sessionTime` (String?) to the `Session` model.\n3. Run `npx prisma migrate dev` to apply changes.\n4. Update TypeScript interfaces in `types/` or relevant model files to reflect these changes.",
        "testStrategy": "Verify database migration runs successfully locally. Check Prisma Studio to ensure new fields are visible and editable.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 45,
        "title": "Implement Sessions API Endpoints",
        "description": "Create backend API routes for managing sessions including creation, retrieval, and updates.",
        "details": "Create/Update `app/api/sessions/route.ts`:\n1. GET: Implement pagination, sorting (date, patient, created), and filtering (patientId, date range, hasTranscript, hasAudio). Return `{ sessions, total, page, totalPages }`.\n2. POST: Accept array of sessions. Handle creation of session records with optional `s3Key`, `audioUrl`, `transcript`, `patientId`.\n\nCreate `app/api/sessions/[id]/route.ts`:\n1. PATCH: Allow updates to `sessionDate`, `sessionTime`, `patientId`, `transcript`. Ensure validation.",
        "testStrategy": "Use Postman or CURL to test GET with query params, POST with single/multiple sessions, and PATCH with valid/invalid data. Verify database state.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 46,
        "title": "Update Patient API for Enhanced Metadata",
        "description": "Extend the existing Patient API to support the new metadata fields during creation and listing.",
        "details": "Modify `app/api/patients/route.ts` (or create if missing):\n1. GET: Ensure it returns the new fields (age, gender, etc.).\n2. POST: Update validation schema (e.g., Zod) to accept `age`, `gender`, `diagnosis`, `notes`.\n3. Ensure `gender` adheres to allowed values if using an enum or specific string set.",
        "testStrategy": "Test creating a patient with full metadata via API. Verify data persistence.",
        "priority": "medium",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 47,
        "title": "Create Patient Management Components",
        "description": "Build frontend components for selecting and creating patients dynamically.",
        "details": "1. Create `CreatePatientModal.tsx`: Use `Dialog` from shadcn. Include form fields for Name, Age, Gender (Select), Diagnosis, Notes. Use `useMutation` to call `POST /api/patients`.\n2. Create `PatientSelector.tsx`: A custom `Select` or `Combobox` component. Fetch patients using React Query. Add a fixed last option \"+ Create New Patient\" which opens the modal.\n3. Ensure the selector optimistically updates or refetches the patient list upon successful creation.",
        "testStrategy": "Unit test the form validation. specific test case: clicking 'Create New Patient' opens modal, saving closes modal and selects the new patient.",
        "priority": "medium",
        "dependencies": [
          46
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 48,
        "title": "Develop Add Session Modal Structure",
        "description": "Create the modal container and tab structure for adding new sessions.",
        "details": "Create `AddSessionModal.tsx`:\n1. Use `Dialog` component.\n2. Implement `Tabs` for \"Upload\" and \"Manual\".\n3. Define state for the modal (isOpen, activeTab).\n4. Include \"Auto Transcribe\" toggle switch.\n5. Placeholder content for tabs to be filled in subsequent tasks.",
        "testStrategy": "Verify modal opens/closes. Check tab switching works.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 49,
        "title": "Implement File Upload Logic for Sessions",
        "description": "Handle file selection, S3 upload, and session creation in the Upload tab.",
        "details": "In `AddSessionModal.tsx` (Upload Tab):\n1. Integrate `FileDropZone` component.\n2. Handle file selection (max 5, max 100MB).\n3. For each file: \n   a. Request presigned URL from `POST /api/upload-url`.\n   b. Upload to S3.\n   c. Call `POST /api/sessions` with `s3Key`.\n   d. Trigger `POST /api/transcribe` if Auto Transcribe is on.\n4. Show progress bars for each file.",
        "testStrategy": "Mock S3 upload. Test uploading 1 file and 5 files. Verify progress state updates.",
        "priority": "high",
        "dependencies": [
          45,
          48
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 50,
        "title": "Implement Manual Session Entry Logic",
        "description": "Handle manual transcript entry and session creation in the Manual tab.",
        "details": "In `AddSessionModal.tsx` (Manual Tab):\n1. Add `Textarea` for transcript.\n2. Add `DatePicker` and `TimePicker` inputs.\n3. Add `PatientSelector` component.\n4. On submit: Call `POST /api/sessions` with the entered data.\n5. Handle success/error states and close modal on success.",
        "testStrategy": "Fill out form manually and submit. Verify payload sent to API matches input.",
        "priority": "medium",
        "dependencies": [
          45,
          48,
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 51,
        "title": "Build Sessions Table Component",
        "description": "Create the main data table to display sessions with sorting and formatting.",
        "details": "Create `SessionsTable.tsx`:\n1. Use shadcn `Table`.\n2. Define columns: Date, Time, Audio (icon), Transcript (preview), Patient.\n3. Accept `sessions` data prop.\n4. Implement column headers with sorting indicators (clicking calls parent sort handler).\n5. Format dates using `date-fns`.",
        "testStrategy": "Render table with mock data. Verify sorting clicks trigger callbacks.",
        "priority": "high",
        "dependencies": [
          44
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 52,
        "title": "Implement Inline Editing for Sessions Table",
        "description": "Enable inline modification of session details directly within the table rows.",
        "details": "Enhance `SessionsTable.tsx`:\n1. Make Date/Time cells clickable to show Popover with Date/Time picker.\n2. Make Patient cell clickable to show `PatientSelector`.\n3. On change, trigger `useMutation` to call `PATCH /api/sessions/[id]`.\n4. Use optimistic updates in React Query to update UI immediately.",
        "testStrategy": "Click to edit a date, change it, verify API call is made and UI updates.",
        "priority": "medium",
        "dependencies": [
          51,
          47
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 53,
        "title": "Create Transcript View/Edit Modal",
        "description": "Build a modal to view full transcripts and edit them.",
        "details": "Create `TranscriptModal.tsx`:\n1. Receive `session` object.\n2. Display transcript in `Textarea` (editable only in edit mode).\n3. Add \"Edit\" toggle button.\n4. \"Save\" button calls `PATCH /api/sessions/[id]` with new transcript.\n5. Add to `SessionsTable` actions.",
        "testStrategy": "Open modal, toggle edit, modify text, save. Verify API patch request.",
        "priority": "medium",
        "dependencies": [
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 54,
        "title": "Create Audio Player Modal",
        "description": "Build a modal for playing back session audio securely.",
        "details": "Create `AudioPlayerModal.tsx`:\n1. Fetch presigned URL using `GET /api/sessions/[id]/audio-url` (or construct if public/protected via other means).\n2. Use HTML5 `<audio>` or a wrapper library.\n3. Controls: Play/Pause, Seek, Volume, Download.\n4. Display file name and duration.\n5. Handle loading states while fetching URL.",
        "testStrategy": "Mock audio URL. Verify player loads and controls work. Verify download link.",
        "priority": "medium",
        "dependencies": [
          45
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 55,
        "title": "Integrate Sessions Page",
        "description": "Assemble all components into the main `/sessions` page with state management.",
        "details": "Create `app/sessions/page.tsx`:\n1. Setup React Query hook for fetching sessions (`useQuery`).\n2. Maintain state for pagination (`page`, `limit`), sorting, and filters.\n3. Render Filter controls (Patient, Date Range).\n4. Render `SessionsTable`.\n5. Render `AddSessionModal` trigger button.\n6. Handle error and loading states.",
        "testStrategy": "Full integration test. Load page, filter results, sort results, change page.",
        "priority": "high",
        "dependencies": [
          51,
          48,
          45
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-11-25T05:27:18.198Z",
      "updated": "2025-11-26T05:33:56.277Z",
      "description": "Tasks for master context"
    }
  }
}