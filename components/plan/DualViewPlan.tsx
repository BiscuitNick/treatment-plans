'use client'

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { TreatmentPlan } from '@/lib/schemas/plan';
import { getPlanHistory, PlanHistoryItem } from '@/app/actions/plan-history';
import { TherapistView } from './TherapistView';
import { ClientView } from './ClientView';
import { PlanEditor } from './PlanEditor';
import { PlanHistory } from './PlanHistory';
import { GoalTimeline } from './GoalTimeline';
import { SuggestionReviewPanel } from '@/components/suggestion/SuggestionReviewPanel';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { AlertCircle, HeartPulse, Meh, Edit, Clock, FileText, TrendingUp, Sparkles, Loader2, ArrowLeft, History, ChevronLeft, ChevronRight, CheckCircle2, Clock4, HelpCircle, Target, Trash2 } from 'lucide-react';
import { SafetyCheckResult, RiskLevel } from '@/lib/types/safety';
import { cn } from '@/lib/utils';
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger, SheetDescription } from '@/components/ui/sheet';
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from '@/components/ui/scroll-area';
import type { SuggestedChanges } from '@/lib/schemas/suggestion';

// Use string type instead of Prisma enum for client component compatibility
type SessionStatusType = 'UNASSIGNED' | 'PENDING' | 'PROCESSED';

interface SessionInfo {
  id: string;
  createdAt: Date;
  summary: string | null;
  transcript: string | null;
  status?: SessionStatusType;
  sessionDate?: Date | null;
  sessionTime?: string | null;
}

interface DualViewPlanProps {
  plan: TreatmentPlan | null; // Can be null for new patients without a plan
  planId?: string; // Needed for API updates
  patientId?: string; // Needed for creating initial plan
  sessionId?: string; // Needed for Update Plan feature
  safetyResult?: SafetyCheckResult;
  transcript?: string;
  sessions?: SessionInfo[]; // For Session History tab
  onPlanUpdated?: (newPlan: TreatmentPlan) => void; // Callback to parent to refresh
}

/**
 * Suggestion data for the review panel
 */
interface SuggestionData {
  id: string;
  sessionSummary: string;
  progressNotes: string | null;
  suggestedChanges: SuggestedChanges;
  createdAt: string;
}

type ViewMode = 'therapist' | 'client';

const AI_DISCLAIMER = "Generated by AI Assistant. This is not a substitute for clinical judgment. Please review carefully.";

/**
 * Historical version data
 */
interface HistoricalVersion {
  id: string;
  version: number;
  content: TreatmentPlan;
  changeType: string;
  changeSummary: string | null;
  createdAt: string;
}

/**
 * Status configuration for goals - matches GoalTimeline styling
 */
const goalStatusConfig: Record<string, { color: string; bgColor: string; borderColor: string; label: string }> = {
  NEW: { color: 'text-blue-700', bgColor: 'bg-blue-50', borderColor: 'border-blue-200', label: 'New' },
  ACTIVE: { color: 'text-blue-700', bgColor: 'bg-blue-50', borderColor: 'border-blue-200', label: 'Active' },
  IN_PROGRESS: { color: 'text-blue-700', bgColor: 'bg-blue-50', borderColor: 'border-blue-200', label: 'In Progress' },
  COMPLETED: { color: 'text-green-700', bgColor: 'bg-green-50', borderColor: 'border-green-200', label: 'Completed' },
  MAINTAINED: { color: 'text-green-700', bgColor: 'bg-green-50', borderColor: 'border-green-200', label: 'Maintained' },
  DEFERRED: { color: 'text-yellow-700', bgColor: 'bg-yellow-50', borderColor: 'border-yellow-200', label: 'Deferred' },
  DISCONTINUED: { color: 'text-red-700', bgColor: 'bg-red-50', borderColor: 'border-red-200', label: 'Discontinued' },
};

/**
 * Component to display goals from a historical version
 */
function HistoricalGoalsView({ goals, version }: { goals: TreatmentPlan['clinicalGoals']; version?: number }) {
  if (!goals || goals.length === 0) {
    return (
      <div className="rounded-md border p-4 bg-muted/10 text-center">
        <Target className="h-8 w-8 mx-auto text-muted-foreground mb-2" />
        <p className="text-sm text-muted-foreground">No goals in this version.</p>
      </div>
    );
  }

  return (
    <div className="rounded-md border p-4 bg-muted/10 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="font-semibold">Goal Status at Version {version}</h3>
          <p className="text-sm text-muted-foreground">
            {goals.length} goal{goals.length !== 1 ? 's' : ''} recorded
          </p>
        </div>
      </div>

      {/* Goals List */}
      <div className="space-y-3">
        {goals.map((goal, idx) => {
          const config = goalStatusConfig[goal.status] || goalStatusConfig.ACTIVE;
          return (
            <div
              key={goal.id || idx}
              className="flex items-center gap-3 p-4 rounded-lg border bg-card"
            >
              <div className={`w-10 h-10 rounded-full ${config.bgColor} flex items-center justify-center flex-shrink-0`}>
                <Target className={`h-5 w-5 ${config.color}`} />
              </div>
              <div className="flex-1 min-w-0">
                <p className="font-medium text-sm">{goal.description}</p>
                {goal.targetDate && (
                  <p className="text-xs text-muted-foreground mt-1">Target: {goal.targetDate}</p>
                )}
              </div>
              <span className={cn(
                "inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium border",
                config.bgColor, config.color, config.borderColor
              )}>
                {config.label}
              </span>
            </div>
          );
        })}
      </div>
    </div>
  );
}

export function DualViewPlan({ plan: initialPlan, planId: initialPlanId, patientId, sessionId, safetyResult, transcript, sessions, onPlanUpdated }: DualViewPlanProps) {
  const [plan, setPlan] = useState<TreatmentPlan | null>(initialPlan);
  const [currentPlanId, setCurrentPlanId] = useState<string | undefined>(initialPlanId);
  const hasPlan = plan !== null;
  const [viewMode, setViewMode] = useState<ViewMode>('therapist');
  const [isEditing, setIsEditing] = useState(false);
  const [isLoadingSuggestion, setIsLoadingSuggestion] = useState(false);
  const [selectedSuggestion, setSelectedSuggestion] = useState<SuggestionData | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [historicalVersion, setHistoricalVersion] = useState<HistoricalVersion | null>(null);
  const [isLoadingVersion, setIsLoadingVersion] = useState(false);
  const [selectedVersionId, setSelectedVersionId] = useState<string | null>(null);
  const [isHistoryOpen, setIsHistoryOpen] = useState(false);
  const [history, setHistory] = useState<PlanHistoryItem[]>([]);
  const [selectedSession, setSelectedSession] = useState<SessionInfo | null>(null);
  const [isGeneratingSummary, setIsGeneratingSummary] = useState(false);
  const [goalTimelineKey, setGoalTimelineKey] = useState(0); // Used to force GoalTimeline refresh
  const router = useRouter();

  // Generate summary for a session
  const handleGenerateSummary = async () => {
    if (!selectedSession || !selectedSession.transcript) return;

    setIsGeneratingSummary(true);
    try {
      const res = await fetch(`/api/sessions/${selectedSession.id}/summary`, {
        method: 'POST',
      });

      if (res.ok) {
        const { summary } = await res.json();
        // Update the selected session with the new summary
        setSelectedSession({ ...selectedSession, summary });
      }
    } catch (error) {
      console.error('Error generating summary:', error);
    } finally {
      setIsGeneratingSummary(false);
    }
  };

  // Delete a session
  const [isDeletingSession, setIsDeletingSession] = useState(false);
  const handleDeleteSession = async (sessionId: string) => {
    if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
      return;
    }

    setIsDeletingSession(true);
    try {
      const res = await fetch(`/api/sessions/${sessionId}`, {
        method: 'DELETE',
      });

      if (res.ok) {
        // Close the dialog and refresh
        setSelectedSession(null);
        router.refresh();
      }
    } catch (error) {
      console.error('Error deleting session:', error);
    } finally {
      setIsDeletingSession(false);
    }
  };

  // Update planId if prop changes (e.g., after page refresh)
  useEffect(() => {
    if (initialPlanId && initialPlanId !== currentPlanId) {
      setCurrentPlanId(initialPlanId);
    }
  }, [initialPlanId, currentPlanId]);

  const isHighRisk = safetyResult && safetyResult.riskLevel === RiskLevel.HIGH;
  const isViewingHistory = historicalVersion !== null;
  const displayPlan = isViewingHistory ? historicalVersion.content : plan;
  const canShowPlanContent = displayPlan !== null;

  useEffect(() => {
    const fetchHistory = async () => {
      if (!currentPlanId) return;
      try {
        const data = await getPlanHistory(currentPlanId);
        setHistory(data);
      } catch (err) {
        console.error("Failed to fetch history:", err);
      }
    };
    fetchHistory();
  }, [currentPlanId, isHistoryOpen]); // Re-fetch when history panel opens to be fresh

  /**
   * Trigger AI analysis and open review dialog with fresh suggestions
   */
  const handleUpdatePlan = async () => {
    if (!sessionId) return;

    setIsLoadingSuggestion(true);
    try {
      const res = await fetch(`/api/sessions/${sessionId}/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ force: true }),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || 'Failed to analyze session');
      }

      const data = await res.json();
      if (data.suggestion) {
        setSelectedSuggestion({
          id: data.suggestion.id,
          sessionSummary: data.suggestion.sessionSummary,
          progressNotes: data.suggestion.progressNotes,
          suggestedChanges: data.suggestion.suggestedChanges,
          createdAt: data.suggestion.createdAt,
        });
      }
    } catch (error) {
      console.error('Failed to analyze session:', error);
    } finally {
      setIsLoadingSuggestion(false);
    }
  };

  /**
   * Handle approve action
   */
  const handleApprove = async (modifications?: Partial<SuggestedChanges>, therapistNotes?: string) => {
    if (!selectedSuggestion) return;

    setIsProcessing(true);
    try {
      const res = await fetch(`/api/suggestions/${selectedSuggestion.id}/approve`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ modifications, therapistNotes }),
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.error || 'Failed to approve');
      }

      const result = await res.json();

      // Update local plan state
      if (result.updatedPlan) {
        setPlan(result.updatedPlan);
        setGoalTimelineKey(k => k + 1); // Force GoalTimeline to refresh
        if (onPlanUpdated) onPlanUpdated(result.updatedPlan);
      }

      setSelectedSuggestion(null);
      router.refresh();
    } catch (error) {
      console.error('Failed to approve suggestion:', error);
    } finally {
      setIsProcessing(false);
    }
  };

  /**
   * Handle reject action
   */
  const handleReject = async (reason: string) => {
    if (!selectedSuggestion) return;

    setIsProcessing(true);
    try {
      const res = await fetch(`/api/suggestions/${selectedSuggestion.id}/reject`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reason }),
      });

      if (!res.ok) {
        const error = await res.json();
        throw new Error(error.error || 'Failed to reject');
      }

      setSelectedSuggestion(null);
      router.refresh();
    } catch (error) {
      console.error('Failed to reject suggestion:', error);
    } finally {
      setIsProcessing(false);
    }
  };

  /**
   * Handle version selection from history panel
   */
  const handleVersionSelect = async (versionId: string, isCurrentVersion: boolean) => {
    if (isCurrentVersion) {
      // Switching back to current version
      setHistoricalVersion(null);
      setSelectedVersionId(null);
      return;
    }

    if (!currentPlanId) return;

    setIsLoadingVersion(true);
    setSelectedVersionId(versionId);
    try {
      const res = await fetch(`/api/plans/${currentPlanId}/versions/${versionId}`);
      if (!res.ok) {
        throw new Error('Failed to fetch version');
      }
      const data = await res.json();
      setHistoricalVersion({
        id: data.version.id,
        version: data.version.version,
        content: data.version.content as TreatmentPlan,
        changeType: data.version.changeType,
        changeSummary: data.version.changeSummary,
        createdAt: data.version.createdAt,
      });
    } catch (error) {
      console.error('Failed to load version:', error);
      setSelectedVersionId(null);
    } finally {
      setIsLoadingVersion(false);
    }
  };

  /**
   * Return to current version
   */
  const handleBackToCurrent = () => {
    setHistoricalVersion(null);
    setSelectedVersionId(null);
  };

  const handleSave = async (updatedPlan: TreatmentPlan) => {
    if (!currentPlanId && !patientId) {
        // If no ID and no patientId (e.g. demo mock mode), just update local state
        setPlan(updatedPlan);
        setIsEditing(false);
        return;
    }

    if (!currentPlanId && patientId) {
        // Creating a new plan for a patient
        const res = await fetch('/api/plans', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              patientId,
              plan: updatedPlan,
              sessionId: sessionId, // Include sessionId to mark as PROCESSED
            })
        });

        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || "Failed to create plan");
        }

        // Success - get the new plan ID from response
        const result = await res.json();
        setCurrentPlanId(result.planId); // Update local planId state
        setPlan(updatedPlan);
        setIsEditing(false);
        setGoalTimelineKey(k => k + 1); // Force GoalTimeline to refresh
        if (onPlanUpdated) onPlanUpdated(updatedPlan);
        router.refresh();
        return;
    }

    // Updating existing plan
    const res = await fetch(`/api/plans/${currentPlanId}/update`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          plan: updatedPlan,
          sessionId: sessionId, // Include sessionId to mark as PROCESSED
        })
    });

    if (!res.ok) {
        const err = await res.json();
        throw new Error(err.error || "Failed to update plan");
    }

    // Success
    setPlan(updatedPlan);
    setIsEditing(false);
    setGoalTimelineKey(k => k + 1); // Force GoalTimeline to refresh
    if (onPlanUpdated) onPlanUpdated(updatedPlan);
  };

  const currentHistoryIndex = isViewingHistory ? history.findIndex(h => h.id === historicalVersion?.id) : -1;
  const prevVersion = isViewingHistory && currentHistoryIndex !== -1 ? history[currentHistoryIndex + 1] : null;
  const nextVersion = isViewingHistory && currentHistoryIndex !== -1 ? history[currentHistoryIndex - 1] : null;
  const isLatestHistory = currentHistoryIndex === 0;

  // Default empty plan structure for creating new plans
  const defaultPlan: TreatmentPlan = {
    riskScore: 'LOW',
    therapistNote: '',
    clientSummary: '',
    clinicalGoals: [],
    clientGoals: [],
    interventions: [],
    homework: '',
  };

  if (isEditing) {
      return <PlanEditor plan={plan || defaultPlan} onSave={handleSave} onCancel={() => setIsEditing(false)} />;
  }

  return (
    <div className="space-y-6">
      {/* Historical Version Banner */}
      {isViewingHistory && (
        <Alert className="bg-amber-50 border-amber-200">
          <History className="h-4 w-4 text-amber-600" />
          <AlertTitle className="text-amber-800">Viewing Historical Version</AlertTitle>
          <AlertDescription className="text-amber-700">
            <div className="flex items-center justify-between">
              <span>
                You are viewing Version {historicalVersion.version} from{' '}
                {new Date(historicalVersion.createdAt).toLocaleDateString()}.
                This is a read-only view.
              </span>
              <Button
                variant="outline"
                size="sm"
                onClick={handleBackToCurrent}
                className="ml-4 border-amber-300 hover:bg-amber-100"
              >
                <ArrowLeft className="h-4 w-4 mr-2" />
                Back to Current
              </Button>
            </div>
          </AlertDescription>
        </Alert>
      )}

      {/* Loading Version Indicator */}
      {isLoadingVersion && (
        <div className="flex items-center justify-center p-4 bg-muted/50 rounded-md">
          <Loader2 className="h-5 w-5 animate-spin mr-2" />
          <span className="text-sm text-muted-foreground">Loading version...</span>
        </div>
      )}

      {/* Safety Alert Banner */}
      {isHighRisk && !isViewingHistory && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Safety Alert Detected</AlertTitle>
          <AlertDescription>
            {safetyResult.reasoning || "High-risk content was identified during analysis. Please review this plan with extreme caution."}
          </AlertDescription>
        </Alert>
      )}

      <Tabs defaultValue="plan" className="w-full">
        <div className="space-y-4 mb-4">
            <TabsList className="w-full grid grid-cols-3">
                <TabsTrigger value="plan">Treatment Plan</TabsTrigger>
                <TabsTrigger value="goals" disabled={!currentPlanId && !isViewingHistory}>
                    <TrendingUp className="h-4 w-4 mr-1" />
                    Goal Progress
                </TabsTrigger>
                <TabsTrigger value="sessions" disabled={(!sessions || sessions.length === 0) || isViewingHistory}>
                    Session History
                </TabsTrigger>
            </TabsList>

            <div className="grid grid-cols-3 gap-2 w-full">
                {/* Slot 1: Update Plan (Current) OR Previous Version (History) */}
                {!isViewingHistory && sessionId ? (
                    <Button
                        variant="outline"
                        onClick={handleUpdatePlan}
                        disabled={isLoadingSuggestion}
                        className="w-full"
                    >
                        {isLoadingSuggestion ? (
                            <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                        ) : (
                            <Sparkles className="h-4 w-4 mr-2" />
                        )}
                        Update Plan
                    </Button>
                ) : isViewingHistory ? (
                    <Button
                        variant="outline"
                        onClick={() => prevVersion && handleVersionSelect(prevVersion.id, false)}
                        disabled={!prevVersion || isLoadingVersion}
                        className="w-full"
                    >
                        <ChevronLeft className="h-4 w-4 mr-2" /> Previous
                    </Button>
                ) : (
                    <div />
                )}

                {/* Slot 2: Edit Plan (Current) OR Next Version (History) */}
                {!isViewingHistory ? (
                    <Button variant="outline" onClick={() => setIsEditing(true)} className="w-full">
                        <Edit className="h-4 w-4 mr-2" /> Edit Plan
                    </Button>
                ) : (
                    <Button
                        variant="outline"
                        onClick={() => {
                            if (nextVersion) {
                                handleVersionSelect(nextVersion.id, false);
                            } else {
                                handleBackToCurrent();
                            }
                        }}
                        disabled={isLoadingVersion}
                        className="w-full"
                    >
                        {nextVersion ? 'Next' : 'Current'} <ChevronRight className="h-4 w-4 ml-2" />
                    </Button>
                )}

                {/* Slot 3: History Sheet */}
                {currentPlanId ? (
                    <Sheet open={isHistoryOpen} onOpenChange={setIsHistoryOpen}>
                        <SheetTrigger asChild>
                            <Button variant="outline" className="w-full">
                                <Clock className="h-4 w-4 mr-2" /> History
                            </Button>
                        </SheetTrigger>
                        <SheetContent className="flex flex-col h-full">
                            <SheetHeader>
                                <SheetTitle>Version History</SheetTitle>
                                <SheetDescription>
                                    Click on a version to view it. Only the current version can be edited.
                                </SheetDescription>
                            </SheetHeader>
                            <div className="flex-1 min-h-0 mt-4">
                                <PlanHistory
                                    planId={currentPlanId}
                                    selectedVersionId={selectedVersionId}
                                    onVersionSelect={(versionId, isCurrentVersion) => {
                                        handleVersionSelect(versionId, isCurrentVersion);
                                        // Close sheet after selection
                                        setIsHistoryOpen(false);
                                    }}
                                    historyItems={history}
                                />
                            </div>
                        </SheetContent>
                    </Sheet>
                ) : (
                    <Button variant="outline" className="w-full" disabled>
                        <Clock className="h-4 w-4 mr-2" /> History
                    </Button>
                )}
            </div>
        </div>

        <TabsContent value="plan" className="flex flex-col h-full">
            {canShowPlanContent ? (
              <>
                {/* Plan View Toggle */}
                <div className="flex items-center gap-3 mb-4 pb-3 border-b">
                    <span className="text-xs font-medium text-muted-foreground uppercase tracking-wide">View</span>
                    <div className="flex space-x-2">
                        <Button
                            variant={viewMode === 'therapist' ? 'default' : 'outline'}
                            onClick={() => setViewMode('therapist')}
                            size="sm"
                            className={cn(viewMode === 'therapist' && "pointer-events-none")}
                        >
                            <HeartPulse className="h-4 w-4 mr-2" /> Therapist
                        </Button>
                        <Button
                            variant={viewMode === 'client' ? 'default' : 'outline'}
                            onClick={() => setViewMode('client')}
                            size="sm"
                            className={cn(viewMode === 'client' && "pointer-events-none")}
                        >
                            <Meh className="h-4 w-4 mr-2" /> Client
                        </Button>
                    </div>
                </div>

                <ScrollArea className="flex-1 h-[60vh]">
                    <div className="pr-4">
                        {viewMode === 'therapist' ? (
                            <TherapistView plan={displayPlan} />
                        ) : (
                            <ClientView plan={displayPlan} />
                        )}
                    </div>
                </ScrollArea>
              </>
            ) : (
              <div className="flex flex-col items-center justify-center h-[60vh] text-center p-8 border rounded-md bg-muted/10">
                <FileText className="h-12 w-12 text-muted-foreground mb-4" />
                <h3 className="text-lg font-medium mb-2">No Treatment Plan Yet</h3>
                <p className="text-muted-foreground max-w-md">
                  Click &quot;Update Plan&quot; to generate an initial plan from a session transcript,
                  or click &quot;Edit Plan&quot; to create one manually.
                </p>
              </div>
            )}
        </TabsContent>

        <TabsContent value="goals">
            {isViewingHistory && displayPlan?.clinicalGoals ? (
              <HistoricalGoalsView goals={displayPlan.clinicalGoals} version={historicalVersion?.version} />
            ) : currentPlanId ? (
              <GoalTimeline key={goalTimelineKey} planId={currentPlanId} />
            ) : null}
        </TabsContent>

        <TabsContent value="sessions">
            <div className="rounded-md border p-4 bg-muted/10">
                <div className="flex items-center gap-2 mb-4 text-muted-foreground">
                    <FileText className="h-4 w-4" />
                    <h3 className="font-medium">Past Sessions</h3>
                </div>
                <ScrollArea className="h-[60vh] w-full">
                    {sessions && sessions.length > 0 ? (
                        <ul className="space-y-4 pr-4">
                            {sessions.map(session => {
                                // Determine status badge
                                const statusConfig = session.status === 'PROCESSED'
                                    ? { label: 'Processed', icon: CheckCircle2, className: 'bg-green-50 text-green-700 border-green-200' }
                                    : session.status === 'PENDING'
                                    ? { label: 'Pending', icon: Clock4, className: 'bg-yellow-50 text-yellow-700 border-yellow-200' }
                                    : { label: 'Unassigned', icon: HelpCircle, className: 'bg-gray-50 text-gray-600 border-gray-200' };
                                const StatusIcon = statusConfig.icon;

                                return (
                                    <li
                                        key={session.id}
                                        className="p-4 rounded-lg border bg-card hover:bg-accent/50 transition-colors cursor-pointer"
                                        onClick={() => setSelectedSession(session)}
                                    >
                                        <div className="flex items-center justify-between mb-2">
                                            <p className="font-medium">
                                                {new Date(session.sessionDate || session.createdAt).toLocaleDateString()}
                                            </p>
                                            {session.status && (
                                                <span className={cn("inline-flex items-center gap-1 px-2 py-0.5 text-xs font-medium rounded-full border", statusConfig.className)}>
                                                    <StatusIcon className="h-3 w-3" />
                                                    {statusConfig.label}
                                                </span>
                                            )}
                                        </div>
                                        <p className="text-sm text-muted-foreground line-clamp-3">
                                            {session.summary || session.transcript || "No transcript available"}
                                        </p>
                                    </li>
                                );
                            })}
                        </ul>
                    ) : (
                        <p className="text-muted-foreground">No sessions recorded.</p>
                    )}
                </ScrollArea>
            </div>
        </TabsContent>
      </Tabs>

      {/* AI Disclaimer Footer */}
      <div className="mt-8 p-4 text-sm text-center text-muted-foreground bg-accent/20 rounded-md border">
        {AI_DISCLAIMER}
      </div>

      {/* Session Details Dialog */}
      <Dialog open={!!selectedSession} onOpenChange={(open) => !open && setSelectedSession(null)}>
        <DialogContent className="max-w-2xl max-h-[80vh] flex flex-col overflow-hidden">
          <DialogHeader>
            <div className="flex items-center justify-between">
              <div>
                <DialogTitle>Session Details</DialogTitle>
                <SheetDescription>
                    {selectedSession && new Date(selectedSession.sessionDate || selectedSession.createdAt).toLocaleDateString()}
                </SheetDescription>
              </div>
              <Button
                variant="ghost"
                size="sm"
                className="text-destructive hover:text-destructive hover:bg-destructive/10"
                onClick={() => selectedSession && handleDeleteSession(selectedSession.id)}
                disabled={isDeletingSession}
              >
                {isDeletingSession ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
                ) : (
                  <Trash2 className="h-4 w-4" />
                )}
              </Button>
            </div>
          </DialogHeader>
          <ScrollArea className="flex-1 min-h-0 mt-4 max-h-[60vh]">
            <div className="space-y-6 pr-4 pb-4">
              {/* Summary Section */}
              <div>
                <div className="flex items-center justify-between mb-2">
                  <h4 className="text-sm font-semibold text-muted-foreground">Summary</h4>
                  {!selectedSession?.summary && selectedSession?.transcript && (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleGenerateSummary}
                      disabled={isGeneratingSummary}
                      className="gap-2"
                    >
                      {isGeneratingSummary ? (
                        <>
                          <Loader2 className="h-4 w-4 animate-spin" />
                          Generating...
                        </>
                      ) : (
                        <>
                          <Sparkles className="h-4 w-4" />
                          Generate Summary
                        </>
                      )}
                    </Button>
                  )}
                </div>
                {selectedSession?.summary ? (
                  <div className="whitespace-pre-wrap text-sm leading-relaxed bg-muted/50 p-4 rounded-lg">
                    {selectedSession.summary}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground italic">
                    {selectedSession?.transcript ? "No summary generated yet." : "No summary available."}
                  </p>
                )}
              </div>

              {/* Transcript Section */}
              <div>
                <h4 className="text-sm font-semibold text-muted-foreground mb-2">Transcript</h4>
                {selectedSession?.transcript ? (
                  <div className="whitespace-pre-wrap text-sm leading-relaxed bg-muted/30 p-4 rounded-lg border">
                    {selectedSession.transcript}
                  </div>
                ) : (
                  <p className="text-sm text-muted-foreground italic">No transcript available.</p>
                )}
              </div>
            </div>
          </ScrollArea>
        </DialogContent>
      </Dialog>

      {/* Suggestion Review Dialog */}
      <Dialog open={!!selectedSuggestion} onOpenChange={(open) => {
        if (!open && !isProcessing) {
          setSelectedSuggestion(null);
        }
      }}>
        <DialogContent className="w-[90vw] max-w-[1200px] max-h-[calc(100vh-2rem)] overflow-hidden p-6">
          <DialogHeader>
            <DialogTitle>Review AI Suggestions</DialogTitle>
          </DialogHeader>
          {selectedSuggestion && (
            <SuggestionReviewPanel
              suggestionId={selectedSuggestion.id}
              sessionSummary={selectedSuggestion.sessionSummary}
              progressNotes={selectedSuggestion.progressNotes}
              suggestedChanges={selectedSuggestion.suggestedChanges}
              currentPlan={plan || defaultPlan}
              createdAt={selectedSuggestion.createdAt}
              onApprove={handleApprove}
              onReject={handleReject}
              isLoading={isProcessing}
            />
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}